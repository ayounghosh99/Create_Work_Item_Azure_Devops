{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport \"../../CommonImports\";\nimport \"../../Core/core.css\";\nimport * as React from \"react\";\nvar FocusWithinContext = React.createContext({});\n\nvar FocusWithin =\n/** @class */\nfunction (_super) {\n  __extends(FocusWithin, _super);\n\n  function FocusWithin() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.blurTimeout = -1;\n    _this.focusCount = 0;\n    _this.focus = false;\n    /**\r\n     * onBlur method that should be attached to the onBlur handler of the\r\n     * continers root element.\r\n     */\n\n    _this.onBlur = function () {\n      // Don't let the focus count go below 0.\n      // We have seen cases where we get a blur event, even when we\n      // do not have focus. One such example is the Office Fabric TrapZone,\n      // which will lose focus, then regain focus and stop propagation on\n      // the event.\n      _this.focusCount = Math.max(0, _this.focusCount - 1); // Clear any previous timeout if we somehow got a second blur event before\n      // ever processing the timeout from the first one.\n\n      if (_this.blurTimeout !== -1) {\n        window.clearTimeout(_this.blurTimeout);\n      } // We must delay the blur processing for two basic reasons:\n      // 1) If focus is transitioning to a child element we will fire a Blur\n      //  followed quickly by a Focus even though focus never left the element.\n      //  This causes problems for things like menus that close on loss of focus.\n      // 2) IE 11 fires the blur before the focus (no other browser does this)\n      //  and this causes the same issue above but also causes focusCount\n      //  inconsistencies.\n\n\n      _this.blurTimeout = window.setTimeout(function () {\n        _this.blurTimeout = -1;\n\n        if (!_this.focusCount) {\n          _this.focus = false; // If we are tracking the focus state we will force a component update.\n\n          if (_this.props.updateStateOnFocusChange) {\n            _this.forceUpdate();\n          }\n\n          if (_this.props.onBlur) {\n            _this.props.onBlur();\n          }\n        }\n      }, 0);\n    };\n    /**\r\n     * onFocus method that should be attached to the onFocus handler of the\r\n     * continer's root element.\r\n     */\n\n\n    _this.onFocus = function (event) {\n      _this.focusCount++; // If focus is just entering one of the child components and not just moving\n      // one child to another we will call the onFocus delegate if supplied.\n\n      if (!_this.focus) {\n        _this.focus = true; // If we are tracking the focus state we will force a component update.\n\n        if (_this.props.updateStateOnFocusChange) {\n          _this.forceUpdate();\n        }\n\n        if (_this.props.onFocus) {\n          _this.props.onFocus(event);\n        }\n      }\n    };\n\n    return _this;\n  }\n\n  FocusWithin.prototype.render = function () {\n    var _this = this;\n\n    return React.createElement(FocusWithinContext.Consumer, null, function (focusWithinContext) {\n      var children;\n      var newProps = {\n        onBlur: _this.onBlur,\n        onFocus: _this.onFocus\n      }; // Save ou parent focus within for potential communication.\n\n      _this.parentFocusWithin = focusWithinContext.focusWithin;\n\n      if (typeof _this.props.children === \"function\") {\n        var child = _this.props.children; // For functional components we pass the hasFocus attribute as well.\n\n        newProps.hasFocus = _this.focus;\n        children = child(newProps);\n      } else {\n        var child = React.Children.only(_this.props.children);\n        children = React.cloneElement(child, __assign(__assign({}, child.props), newProps), child.props.children);\n      }\n\n      return React.createElement(FocusWithinContext.Provider, {\n        value: {\n          focusWithin: _this\n        }\n      }, children);\n    });\n  };\n  /**\r\n   * componentWillUnmount is used to cleanup the component state.\r\n   *\r\n   * @NOTE: The main thing we need to deal with is when this component is unmounted\r\n   * while it has focus. We need to get this FocusWithin and all of its parents state\r\n   * updated since focus will move directly to the body without a blur event.\r\n   */\n\n\n  FocusWithin.prototype.componentWillUnmount = function () {\n    if (this.blurTimeout !== -1) {\n      window.clearTimeout(this.blurTimeout);\n      this.blurTimeout = -1;\n    }\n\n    if (this.focusCount > 0) {\n      this.unmountWithFocus(false);\n    }\n  };\n  /**\r\n   * hasFocus returns true if the focus is contained within the focus component\r\n   * hierarchy. This includes portals, the element may or may not\r\n   * be a direct descendant of the focus component in the DOM structure.\r\n   */\n\n\n  FocusWithin.prototype.hasFocus = function () {\n    return this.focusCount > 0;\n  };\n  /**\r\n   * When the focusWithin unmounts we need to determine if we currently have focus.\r\n   * If we do, focus will be moved silently to the body. We need to cleanup the\r\n   * focusWithin's that are affected by this silent change.\r\n   */\n\n\n  FocusWithin.prototype.unmountWithFocus = function (fromParent) {\n    if (this.focusCount > 0) {\n      this.focusCount--;\n\n      if (this.focusCount > 0) {\n        // If we are tracking the focus state we will force a component update.\n        if (fromParent) {\n          this.focusCount = 0;\n          this.focus = false;\n\n          if (this.props.updateStateOnFocusChange) {\n            this.forceUpdate();\n          }\n\n          if (this.props.onBlur) {\n            this.props.onBlur();\n          }\n        }\n      } // Notify the parent focus within that the mounted focus component is unmounting.\n\n\n      if (this.parentFocusWithin) {\n        this.parentFocusWithin.unmountWithFocus(true);\n      }\n    }\n  };\n\n  FocusWithin.defaultProps = {\n    updateStateOnFocusChange: true\n  };\n  return FocusWithin;\n}(React.Component);\n\nexport { FocusWithin };","map":{"version":3,"sources":["/Users/ayounghosh/Downloads/Create_Work_Item_Azure_Devops/Front_End/node_modules/azure-devops-ui/Components/FocusWithin/FocusWithin.js"],"names":["__assign","__extends","React","FocusWithinContext","createContext","FocusWithin","_super","_this","apply","arguments","blurTimeout","focusCount","focus","onBlur","Math","max","window","clearTimeout","setTimeout","props","updateStateOnFocusChange","forceUpdate","onFocus","event","prototype","render","createElement","Consumer","focusWithinContext","children","newProps","parentFocusWithin","focusWithin","child","hasFocus","Children","only","cloneElement","Provider","value","componentWillUnmount","unmountWithFocus","fromParent","defaultProps","Component"],"mappings":"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","sourcesContent":["import { __assign, __extends } from \"tslib\";\r\nimport \"../../CommonImports\";\r\nimport \"../../Core/core.css\";\r\nimport * as React from \"react\";\r\nvar FocusWithinContext = React.createContext({});\r\nvar FocusWithin = /** @class */ (function (_super) {\r\n    __extends(FocusWithin, _super);\r\n    function FocusWithin() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.blurTimeout = -1;\r\n        _this.focusCount = 0;\r\n        _this.focus = false;\r\n        /**\r\n         * onBlur method that should be attached to the onBlur handler of the\r\n         * continers root element.\r\n         */\r\n        _this.onBlur = function () {\r\n            // Don't let the focus count go below 0.\r\n            // We have seen cases where we get a blur event, even when we\r\n            // do not have focus. One such example is the Office Fabric TrapZone,\r\n            // which will lose focus, then regain focus and stop propagation on\r\n            // the event.\r\n            _this.focusCount = Math.max(0, _this.focusCount - 1);\r\n            // Clear any previous timeout if we somehow got a second blur event before\r\n            // ever processing the timeout from the first one.\r\n            if (_this.blurTimeout !== -1) {\r\n                window.clearTimeout(_this.blurTimeout);\r\n            }\r\n            // We must delay the blur processing for two basic reasons:\r\n            // 1) If focus is transitioning to a child element we will fire a Blur\r\n            //  followed quickly by a Focus even though focus never left the element.\r\n            //  This causes problems for things like menus that close on loss of focus.\r\n            // 2) IE 11 fires the blur before the focus (no other browser does this)\r\n            //  and this causes the same issue above but also causes focusCount\r\n            //  inconsistencies.\r\n            _this.blurTimeout = window.setTimeout(function () {\r\n                _this.blurTimeout = -1;\r\n                if (!_this.focusCount) {\r\n                    _this.focus = false;\r\n                    // If we are tracking the focus state we will force a component update.\r\n                    if (_this.props.updateStateOnFocusChange) {\r\n                        _this.forceUpdate();\r\n                    }\r\n                    if (_this.props.onBlur) {\r\n                        _this.props.onBlur();\r\n                    }\r\n                }\r\n            }, 0);\r\n        };\r\n        /**\r\n         * onFocus method that should be attached to the onFocus handler of the\r\n         * continer's root element.\r\n         */\r\n        _this.onFocus = function (event) {\r\n            _this.focusCount++;\r\n            // If focus is just entering one of the child components and not just moving\r\n            // one child to another we will call the onFocus delegate if supplied.\r\n            if (!_this.focus) {\r\n                _this.focus = true;\r\n                // If we are tracking the focus state we will force a component update.\r\n                if (_this.props.updateStateOnFocusChange) {\r\n                    _this.forceUpdate();\r\n                }\r\n                if (_this.props.onFocus) {\r\n                    _this.props.onFocus(event);\r\n                }\r\n            }\r\n        };\r\n        return _this;\r\n    }\r\n    FocusWithin.prototype.render = function () {\r\n        var _this = this;\r\n        return (React.createElement(FocusWithinContext.Consumer, null, function (focusWithinContext) {\r\n            var children;\r\n            var newProps = {\r\n                onBlur: _this.onBlur,\r\n                onFocus: _this.onFocus\r\n            };\r\n            // Save ou parent focus within for potential communication.\r\n            _this.parentFocusWithin = focusWithinContext.focusWithin;\r\n            if (typeof _this.props.children === \"function\") {\r\n                var child = _this.props.children;\r\n                // For functional components we pass the hasFocus attribute as well.\r\n                newProps.hasFocus = _this.focus;\r\n                children = child(newProps);\r\n            }\r\n            else {\r\n                var child = React.Children.only(_this.props.children);\r\n                children = React.cloneElement(child, __assign(__assign({}, child.props), newProps), child.props.children);\r\n            }\r\n            return React.createElement(FocusWithinContext.Provider, { value: { focusWithin: _this } }, children);\r\n        }));\r\n    };\r\n    /**\r\n     * componentWillUnmount is used to cleanup the component state.\r\n     *\r\n     * @NOTE: The main thing we need to deal with is when this component is unmounted\r\n     * while it has focus. We need to get this FocusWithin and all of its parents state\r\n     * updated since focus will move directly to the body without a blur event.\r\n     */\r\n    FocusWithin.prototype.componentWillUnmount = function () {\r\n        if (this.blurTimeout !== -1) {\r\n            window.clearTimeout(this.blurTimeout);\r\n            this.blurTimeout = -1;\r\n        }\r\n        if (this.focusCount > 0) {\r\n            this.unmountWithFocus(false);\r\n        }\r\n    };\r\n    /**\r\n     * hasFocus returns true if the focus is contained within the focus component\r\n     * hierarchy. This includes portals, the element may or may not\r\n     * be a direct descendant of the focus component in the DOM structure.\r\n     */\r\n    FocusWithin.prototype.hasFocus = function () {\r\n        return this.focusCount > 0;\r\n    };\r\n    /**\r\n     * When the focusWithin unmounts we need to determine if we currently have focus.\r\n     * If we do, focus will be moved silently to the body. We need to cleanup the\r\n     * focusWithin's that are affected by this silent change.\r\n     */\r\n    FocusWithin.prototype.unmountWithFocus = function (fromParent) {\r\n        if (this.focusCount > 0) {\r\n            this.focusCount--;\r\n            if (this.focusCount > 0) {\r\n                // If we are tracking the focus state we will force a component update.\r\n                if (fromParent) {\r\n                    this.focusCount = 0;\r\n                    this.focus = false;\r\n                    if (this.props.updateStateOnFocusChange) {\r\n                        this.forceUpdate();\r\n                    }\r\n                    if (this.props.onBlur) {\r\n                        this.props.onBlur();\r\n                    }\r\n                }\r\n            }\r\n            // Notify the parent focus within that the mounted focus component is unmounting.\r\n            if (this.parentFocusWithin) {\r\n                this.parentFocusWithin.unmountWithFocus(true);\r\n            }\r\n        }\r\n    };\r\n    FocusWithin.defaultProps = {\r\n        updateStateOnFocusChange: true\r\n    };\r\n    return FocusWithin;\r\n}(React.Component));\r\nexport { FocusWithin };\r\n"]},"metadata":{},"sourceType":"module"}