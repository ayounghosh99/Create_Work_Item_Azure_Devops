{"ast":null,"code":"import { __extends, __spreadArrays } from \"tslib\";\nimport * as React from \"react\";\n/**\r\n * An Observable implementation that will track a set of subscribers and supports\r\n * notifications when the underlying system changes.\r\n */\n\nvar Observable =\n/** @class */\nfunction () {\n  function Observable() {\n    this.observers = {};\n    this.subscriberCount = 0;\n  }\n  /**\r\n   * notify is used to send the event to all subscribers that have signed up for this events\r\n   * action. This means they have subscribed directly to this action, or to all actions.\r\n   * If the caller requested the event be persisted the event will be fired in order to new\r\n   * subscribers as well when they subscribe.\r\n   *\r\n   * @param value - The object that represents the event data.\r\n   *\r\n   * @param action - The action that happened on this observable to produce the event.\r\n   *\r\n   * @param persistEvent - Optional value that determines if all future subscribers will\r\n   *  recieve the event as well.\r\n   */\n\n\n  Observable.prototype.notify = function (value, action, persistEvent) {\n    var executeObserverAction = function (observer, value, action) {\n      try {\n        observer(value, action);\n      } catch (ex) {\n        console.warn(ex);\n\n        if (ex && typeof ErrorEvent === \"function\") {\n          window.dispatchEvent(new ErrorEvent(\"error\", {\n            error: ex,\n            filename: \"Observable.ts\",\n            message: ex.message\n          }));\n        }\n      }\n    }; // NOTE: We need to make a copy of the observers since they may change during notification.\n\n\n    if (this.observers[action]) {\n      var observers = this.observers[action].slice();\n\n      for (var observerIndex = 0; observerIndex < observers.length; observerIndex++) {\n        executeObserverAction(observers[observerIndex], value, action);\n      }\n    }\n\n    if (this.observers[\"\"]) {\n      var observers = this.observers[\"\"].slice();\n\n      for (var observerIndex = 0; observerIndex < observers.length; observerIndex++) {\n        executeObserverAction(observers[observerIndex], value, action);\n      }\n    } // If the caller wants this event sent to all subscribers, even future ones, track it.\n\n\n    if (persistEvent) {\n      if (!this.events) {\n        this.events = [];\n      }\n\n      this.events.push({\n        action: action,\n        value: value\n      });\n    }\n  };\n\n  Observable.prototype.subscribe = function (observer, action) {\n    action = action || \"\";\n\n    if (!this.observers[action]) {\n      this.observers[action] = [];\n    }\n\n    this.observers[action].push(observer);\n    this.subscriberCount++; // Fire the callback for any events that were persisted when they were sent.\n\n    if (this.events) {\n      for (var _i = 0, _a = this.events; _i < _a.length; _i++) {\n        var event_1 = _a[_i];\n\n        if (!action || event_1.action === action) {\n          observer(event_1.value, event_1.action);\n        }\n      }\n    }\n\n    return observer;\n  };\n\n  Observable.prototype.unsubscribe = function (observer, action) {\n    action = action || \"\";\n\n    if (this.observers[action]) {\n      var observerIndex = this.observers[action].indexOf(observer);\n\n      if (observerIndex >= 0) {\n        this.observers[action].splice(observerIndex, 1);\n        this.subscriberCount--;\n      }\n    }\n  };\n\n  return Observable;\n}();\n\nexport { Observable };\nexport var ObservableLike;\n\n(function (ObservableLike) {\n  /**\r\n   * Check whether the specified object is an observable or not.\r\n   *\r\n   * @param observableLike Object to perform observable check.\r\n   */\n  function isObservable(observableLike) {\n    return observableLike && typeof observableLike.subscribe === \"function\";\n  }\n\n  ObservableLike.isObservable = isObservable;\n\n  function getValue(observableLike) {\n    if (isObservable(observableLike)) {\n      return observableLike.value;\n    }\n\n    return observableLike;\n  }\n\n  ObservableLike.getValue = getValue;\n  /**\r\n   * Subscribes to the specified object if it is an observable.\r\n   *\r\n   * @param observableLike Object to subscribe its value change if applicable.\r\n   * @param observer Delegate to be executed when the underlying data changes.\r\n   * @param action Optional argument that allows the consumer to supply a action\r\n   *  with the delegate. If the action is supplied only those actions are delievered,\r\n   *  while all actions are delivered is no action is supplied.\r\n   * @returns observer\r\n   */\n\n  function subscribe(observableLike, observer, action) {\n    if (isObservable(observableLike)) {\n      return observableLike.subscribe(observer, action);\n    }\n\n    return function () {};\n  }\n\n  ObservableLike.subscribe = subscribe;\n  /**\r\n   * Unsubscribes from the specified object if it is an observable.\r\n   *\r\n   * @param observableLike Object to subscribe its value change if applicable.\r\n   * @param observer Delegate to be executed when the underlying data changes.\r\n   * @param action Optional argument that allows the consumer to supply a action\r\n   *  with the delegate. If the action is supplied only those actions are delievered,\r\n   *  while all actions are delivered is no action is supplied.\r\n   */\n\n  function unsubscribe(observableLike, observer, action) {\n    if (isObservable(observableLike)) {\n      observableLike.unsubscribe(observer, action);\n    }\n  }\n\n  ObservableLike.unsubscribe = unsubscribe;\n})(ObservableLike || (ObservableLike = {}));\n\nvar ObservableValue =\n/** @class */\nfunction (_super) {\n  __extends(ObservableValue, _super);\n\n  function ObservableValue(value) {\n    var _this = _super.call(this) || this;\n\n    _this.v = value;\n    return _this;\n  }\n\n  Object.defineProperty(ObservableValue.prototype, \"value\", {\n    get: function () {\n      return this.v;\n    },\n    set: function (value) {\n      this.v = value;\n      this.notify(this.v, \"set\");\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return ObservableValue;\n}(Observable);\n\nexport { ObservableValue };\n/**\r\n * An ObservableObject can be used to key a named collection of properties\r\n * and offer an observable endpoint.\r\n */\n\nvar ObservableObject =\n/** @class */\nfunction (_super) {\n  __extends(ObservableObject, _super);\n\n  function ObservableObject() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.objects = {};\n    return _this;\n  }\n\n  ObservableObject.prototype.add = function (objectName, objectDefinition) {\n    if (!this.objects.hasOwnProperty(objectName)) {\n      this.objects[objectName] = objectDefinition;\n      this.notify({\n        key: objectName,\n        value: objectDefinition\n      }, \"add\");\n    }\n  };\n\n  ObservableObject.prototype.get = function (objectName) {\n    return this.objects[objectName];\n  };\n\n  ObservableObject.prototype.set = function (objectName, objectDefinition) {\n    if (this.objects.hasOwnProperty(objectName)) {\n      this.objects[objectName] = objectDefinition;\n      this.notify({\n        key: objectName,\n        value: objectDefinition\n      }, \"replace\");\n    } else {\n      this.add(objectName, objectDefinition);\n    }\n  };\n\n  ObservableObject.prototype.keys = function () {\n    return Object.keys(this.objects);\n  };\n\n  return ObservableObject;\n}(Observable);\n\nexport { ObservableObject };\n/**\r\n * EventTypes:\r\n *  change - { changedItems, index }\r\n *  push - {addedItems, index }\r\n *  pop - { index, removedItems}\r\n *  removeAll - {index, removedItems }\r\n *  splice - { addedItems, index, removedItems }\r\n */\n\nvar ObservableArray =\n/** @class */\nfunction (_super) {\n  __extends(ObservableArray, _super);\n\n  function ObservableArray(items) {\n    if (items === void 0) {\n      items = [];\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.internalItems = items || [];\n    return _this;\n  }\n\n  ObservableArray.prototype.change = function (start) {\n    var _a;\n\n    var items = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      items[_i - 1] = arguments[_i];\n    }\n\n    (_a = this.internalItems).splice.apply(_a, __spreadArrays([start, items.length], items));\n\n    this.notify({\n      index: start,\n      changedItems: items\n    }, \"change\");\n    return items.length;\n  };\n\n  Object.defineProperty(ObservableArray.prototype, \"length\", {\n    get: function () {\n      return this.internalItems.length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ObservableArray.prototype.push = function () {\n    var _a;\n\n    var items = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      items[_i] = arguments[_i];\n    }\n\n    if (items.length) {\n      var index = this.internalItems.length;\n\n      (_a = this.internalItems).push.apply(_a, items);\n\n      this.notify({\n        addedItems: items,\n        index: index\n      }, \"push\");\n    }\n\n    return items.length;\n  };\n\n  ObservableArray.prototype.pop = function () {\n    var item = this.internalItems.pop();\n\n    if (item !== undefined) {\n      this.notify({\n        index: this.internalItems.length,\n        removedItems: [item]\n      }, \"pop\");\n    }\n\n    return item;\n  };\n\n  ObservableArray.prototype.removeAll = function (filter) {\n    var removedItems = [];\n    var remainingItems = [];\n\n    for (var _i = 0, _a = this.internalItems; _i < _a.length; _i++) {\n      var item = _a[_i];\n\n      if (!filter || filter(item)) {\n        removedItems.push(item);\n      } else {\n        remainingItems.push(item);\n      }\n    }\n\n    if (removedItems.length > 0) {\n      this.internalItems.splice(0, this.internalItems.length);\n\n      for (var _b = 0, remainingItems_1 = remainingItems; _b < remainingItems_1.length; _b++) {\n        var item = remainingItems_1[_b];\n        this.internalItems.push(item);\n      }\n\n      this.notify({\n        index: 0,\n        removedItems: removedItems\n      }, \"removeAll\");\n    }\n\n    return removedItems;\n  };\n\n  ObservableArray.prototype.splice = function (start, deleteCount) {\n    var _a;\n\n    var itemsToAdd = [];\n\n    for (var _i = 2; _i < arguments.length; _i++) {\n      itemsToAdd[_i - 2] = arguments[_i];\n    }\n\n    var removedItems = (_a = this.internalItems).splice.apply(_a, __spreadArrays([start, deleteCount], itemsToAdd));\n\n    this.notify({\n      addedItems: itemsToAdd,\n      index: start,\n      removedItems: removedItems\n    }, \"splice\");\n    return removedItems;\n  };\n\n  Object.defineProperty(ObservableArray.prototype, \"value\", {\n    get: function () {\n      return this.internalItems;\n    },\n    set: function (items) {\n      // Preserve the original array, but avoid the \"...\" arguments issue with splice/push\n      var removedItems;\n\n      if (items === this.internalItems) {\n        // Special case for someone passing us the same internal array that we are already using\n        // We don't need to modify the internalItems. The \"removedItems\" in the event is\n        // not going to be accurate in the case that someone modified this internal array\n        // outside of the observable -- we won't know the prior state in that case.\n        removedItems = this.internalItems;\n      } else {\n        // Clear out the existing items\n        removedItems = this.internalItems.slice();\n        this.internalItems.length = 0; // Add all new items\n\n        if (items.length) {\n          for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {\n            var item = items_1[_i];\n            this.internalItems.push(item);\n          }\n        }\n      }\n\n      this.notify({\n        addedItems: items,\n        index: 0,\n        removedItems: removedItems\n      }, \"splice\");\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return ObservableArray;\n}(Observable);\n\nexport { ObservableArray };\n/**\r\n * An Observable Collection takes an arry of arrays or observable arrays\r\n * and flattens out the items into a single readonly observable array\r\n * (with all the underlying array values aggregated together).\r\n *\r\n * This handles subscribing to any underlying observable arrays and\r\n * updating the aggregate array as appropriate (and notifying subscribers)\r\n */\n\nvar ObservableCollection =\n/** @class */\nfunction (_super) {\n  __extends(ObservableCollection, _super);\n\n  function ObservableCollection() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.collections = [];\n    _this.items = [];\n    return _this;\n  }\n\n  Object.defineProperty(ObservableCollection.prototype, \"length\", {\n    get: function () {\n      if (!this.subscriberCount) {\n        this.recalculateItems();\n      }\n\n      return this.items.length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ObservableCollection.prototype, \"value\", {\n    get: function () {\n      if (!this.subscriberCount) {\n        this.recalculateItems();\n      }\n\n      return this.items;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Adds an additional collection of items to the end of the array\r\n   *\r\n   * @param collection Array of items or an observable array of items\r\n   * @params transformItems Delegate to process each item that is pulled from the given collection\r\n   */\n\n  ObservableCollection.prototype.push = function (collection, transformItems) {\n    var collectionEntry;\n    var pushedItems;\n\n    if (ObservableLike.isObservable(collection)) {\n      var observable = collection;\n      var subscriber = this.getSubscriber(this.collections.length, transformItems);\n      collectionEntry = {\n        observable: observable,\n        subscriber: subscriber,\n        transformItems: transformItems,\n        items: []\n      };\n      pushedItems = observable.value;\n\n      if (this.subscriberCount) {\n        ObservableLike.subscribe(collectionEntry.observable, subscriber);\n      }\n    } else if (collection.length) {\n      pushedItems = collection;\n      collectionEntry = {\n        items: this.transformItems(pushedItems, transformItems)\n      };\n    }\n\n    if (collectionEntry) {\n      this.collections.push(collectionEntry);\n\n      if (this.subscriberCount && pushedItems.length) {\n        var newItems = this.transformItems(pushedItems, transformItems);\n\n        for (var _i = 0, newItems_1 = newItems; _i < newItems_1.length; _i++) {\n          var newItem = newItems_1[_i];\n          this.items.push(newItem);\n        }\n\n        this.notify({\n          addedItems: newItems,\n          index: this.items.length - newItems.length\n        }, \"push\");\n      }\n    }\n  };\n\n  ObservableCollection.prototype.subscribe = function (observer, action) {\n    var subscription = _super.prototype.subscribe.call(this, observer, action);\n\n    if (this.subscriberCount === 1) {\n      this.recalculateItems();\n\n      for (var _i = 0, _a = this.collections; _i < _a.length; _i++) {\n        var collection = _a[_i];\n\n        if (collection.subscriber) {\n          collection.observable.subscribe(collection.subscriber);\n        }\n      }\n    }\n\n    return subscription;\n  };\n\n  ObservableCollection.prototype.unsubscribe = function (observer, action) {\n    _super.prototype.unsubscribe.call(this, observer, action);\n\n    if (this.subscriberCount === 0) {\n      for (var _i = 0, _a = this.collections; _i < _a.length; _i++) {\n        var collection = _a[_i];\n\n        if (collection.subscriber) {\n          collection.observable.unsubscribe(collection.subscriber);\n        }\n      }\n    }\n  };\n  /**\r\n   * Recalculate items. This is necessary while we work without subscribers, as we're not listening to changes in observable inner collections.\r\n   * Once the first subscriber joins, items collection will be in sync real-time.\r\n   */\n\n\n  ObservableCollection.prototype.recalculateItems = function () {\n    this.items.length = 0;\n\n    for (var _i = 0, _a = this.collections; _i < _a.length; _i++) {\n      var collection = _a[_i];\n\n      if (collection.observable) {\n        collection.items = this.transformItems(collection.observable.value, collection.transformItems);\n      }\n\n      for (var _b = 0, _c = collection.items; _b < _c.length; _b++) {\n        var item = _c[_b];\n        this.items.push(item);\n      }\n    }\n  };\n\n  ObservableCollection.prototype.transformItems = function (inputItems, transformInput) {\n    var transformedItems;\n\n    if (!inputItems) {\n      transformedItems = [];\n    } else if (transformInput) {\n      transformedItems = [];\n\n      for (var _i = 0, inputItems_1 = inputItems; _i < inputItems_1.length; _i++) {\n        var inputItem = inputItems_1[_i];\n        var transformedItem = transformInput(inputItem);\n\n        if (transformedItem !== undefined) {\n          transformedItems.push(transformedItem);\n        }\n      }\n    } else {\n      transformedItems = inputItems;\n    }\n\n    return transformedItems;\n  };\n\n  ObservableCollection.prototype.getSubscriber = function (collectionIndex, transformInput) {\n    var _this = this;\n\n    return function (args) {\n      var _a; // Find the index in our aggregate array\n\n\n      var index = args.index;\n\n      for (var i = 0; i < collectionIndex; i++) {\n        index += _this.collections[i].items.length;\n      }\n\n      if (args.changedItems) {\n        // Handle change event\n        var changedItems = _this.transformItems(args.changedItems, transformInput);\n\n        (_a = _this.items).splice.apply(_a, __spreadArrays([index, args.changedItems.length], changedItems));\n\n        _this.notify({\n          changedItems: changedItems,\n          index: index\n        }, \"change\");\n      } else {\n        // Handle splice, push, pop events\n        var removedItems = _this.transformItems(args.removedItems, transformInput);\n\n        var addedItems = _this.transformItems(args.addedItems, transformInput); // We would normally just call splice here with 3 arguments, but splice takes a \"...\" argument for added items\n        // which passes array elements on the stack and is therefore limited (to 32K/64K on some browsers)\n        // Remove the removedItems first\n\n\n        _this.items.splice(index, removedItems.length); // Slice-off any remaining items past where we want to insert\n\n\n        var endItems = _this.items.splice(index); // Push the addedItems followed by the endItems that we just removed\n\n\n        for (var _i = 0, addedItems_1 = addedItems; _i < addedItems_1.length; _i++) {\n          var item = addedItems_1[_i];\n\n          _this.items.push(item);\n        }\n\n        for (var _b = 0, endItems_1 = endItems; _b < endItems_1.length; _b++) {\n          var item = endItems_1[_b];\n\n          _this.items.push(item);\n        }\n\n        _this.notify({\n          removedItems: removedItems,\n          addedItems: addedItems,\n          index: index\n        }, \"splice\");\n      }\n    };\n  };\n\n  return ObservableCollection;\n}(Observable);\n\nexport { ObservableCollection };\n\nvar ReadyableObservableArray =\n/** @class */\nfunction (_super) {\n  __extends(ReadyableObservableArray, _super);\n\n  function ReadyableObservableArray(items, ready) {\n    if (items === void 0) {\n      items = [];\n    }\n\n    if (ready === void 0) {\n      ready = false;\n    }\n\n    var _this = _super.call(this, items) || this;\n\n    _this.ready = new ObservableValue(ready);\n    return _this;\n  }\n\n  return ReadyableObservableArray;\n}(ObservableArray);\n\nexport { ReadyableObservableArray };\n/**\r\n * React Hooks extension that allows the consumer to track Observables with a useState like\r\n * hooks API.\r\n *\r\n * @param initialState Initial value for the state, or a function that will resolve the value\r\n * the when the value is initialized.\r\n */\n\nexport function useObservable(initialState) {\n  var underlyingState = React.useState(initialState)[0];\n  var observable = React.useState(function () {\n    return new ObservableValue(underlyingState);\n  })[0];\n\n  var updateState = function (updatedState) {\n    if (typeof updatedState === \"function\") {\n      observable.value = updatedState(observable.value);\n    } else {\n      observable.value = updatedState;\n    }\n  };\n\n  return [observable, updateState];\n}\n/**\r\n * React Hooks extension that allows the consmer to track ObservableArrays with a useState like\r\n * hooks API.\r\n *\r\n * @param initialState Initial value for the state, or a function that will resolve the value\r\n * the when the value is initialized.\r\n */\n\nexport function useObservableArray(initialState) {\n  var underlyingState = React.useState(initialState)[0];\n  var reactState = React.useState(new ObservableArray(underlyingState));\n\n  var updateState = function (updatedState) {\n    if (typeof updatedState === \"function\") {\n      reactState[0].value = updatedState(reactState[0].value);\n    } else {\n      reactState[0].value = updatedState;\n    }\n  };\n\n  return [reactState[0], updateState];\n}\n/**\r\n * React Hooks extension that provides a constant reference to an ObservableValue which will update\r\n * based on another observable.\r\n *\r\n * @remarks\r\n * The subscription will be safely unsubscribed any time:\r\n * - The source observable points to a new object\r\n * - The callback dependencies array changes\r\n * - The component is unmounted\r\n *\r\n * @param sourceObservable\r\n * @param getDerivedValue\r\n * @param callbackDependencies\r\n */\n\nexport function useDerivedObservable(sourceObservable, getDerivedValue, callbackDependencies) {\n  var initialValue = getDerivedValue(sourceObservable.value);\n\n  var _a = useObservable(initialValue),\n      observable = _a[0],\n      setValue = _a[1];\n\n  var getDerivedValueCallback = React.useCallback(getDerivedValue, callbackDependencies);\n  useSubscription(sourceObservable, function (newValue) {\n    var derivedValue = getDerivedValueCallback(newValue);\n    setValue(derivedValue);\n  }, callbackDependencies);\n  return observable;\n}\n/**\r\n * React Hooks extension that fires a callback whenever the provided observable changes.\r\n *\r\n * @remarks\r\n * The subscription will be safely unsubscribed any time:\r\n * - The source observable points to a new object\r\n * - The callback dependencies array changes\r\n * - The component is unmounted\r\n *\r\n * @param sourceObservable\r\n * @param callbackFn\r\n * @param callbackDependencies\r\n */\n\nexport function useSubscription(sourceObservable, callbackFn, callbackDependencies) {\n  if (callbackDependencies === void 0) {\n    callbackDependencies = [];\n  }\n\n  var callback = React.useCallback(callbackFn, callbackDependencies);\n  React.useEffect(function () {\n    sourceObservable.subscribe(callback);\n    return function () {\n      return sourceObservable.unsubscribe(callback);\n    };\n  }, [sourceObservable, callback]);\n}\n/**\r\n * React Hooks extension that debounces the firing of a callback whenever the provided observable changes.\r\n *\r\n * @remarks\r\n * The subscription will be safely unsubscribed any time:\r\n * - The source observable points to a new object\r\n * - The timeout value changes\r\n * - The callback dependencies array changes\r\n * - The component is unmounted\r\n *\r\n * @param sourceObservable\r\n * @param callbackFn\r\n * @param callbackDependencies\r\n */\n\nexport function useDebouncedSubscription(sourceObservable, debounceMs, callbackFn, callbackDependencies) {\n  if (callbackDependencies === void 0) {\n    callbackDependencies = [];\n  }\n\n  var timeoutRef = React.useRef(null);\n  useSubscription(sourceObservable, function (value) {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n\n    timeoutRef.current = setTimeout(function () {\n      callbackFn(value);\n      timeoutRef.current = null;\n    }, debounceMs);\n  }, __spreadArrays([debounceMs], callbackDependencies));\n}","map":{"version":3,"sources":["/Users/ayounghosh/Downloads/Create_Work_Item_Azure_Devops/Front_End/node_modules/azure-devops-ui/Core/Observable.js"],"names":["__extends","__spreadArrays","React","Observable","observers","subscriberCount","prototype","notify","value","action","persistEvent","executeObserverAction","observer","ex","console","warn","ErrorEvent","window","dispatchEvent","error","filename","message","slice","observerIndex","length","events","push","subscribe","_i","_a","event_1","unsubscribe","indexOf","splice","ObservableLike","isObservable","observableLike","getValue","ObservableValue","_super","_this","call","v","Object","defineProperty","get","set","enumerable","configurable","ObservableObject","apply","arguments","objects","add","objectName","objectDefinition","hasOwnProperty","key","keys","ObservableArray","items","internalItems","change","start","index","changedItems","addedItems","pop","item","undefined","removedItems","removeAll","filter","remainingItems","_b","remainingItems_1","deleteCount","itemsToAdd","items_1","ObservableCollection","collections","recalculateItems","collection","transformItems","collectionEntry","pushedItems","observable","subscriber","getSubscriber","newItems","newItems_1","newItem","subscription","_c","inputItems","transformInput","transformedItems","inputItems_1","inputItem","transformedItem","collectionIndex","args","i","endItems","addedItems_1","endItems_1","ReadyableObservableArray","ready","useObservable","initialState","underlyingState","useState","updateState","updatedState","useObservableArray","reactState","useDerivedObservable","sourceObservable","getDerivedValue","callbackDependencies","initialValue","setValue","getDerivedValueCallback","useCallback","useSubscription","newValue","derivedValue","callbackFn","callback","useEffect","useDebouncedSubscription","debounceMs","timeoutRef","useRef","current","clearTimeout","setTimeout"],"mappings":"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","sourcesContent":["import { __extends, __spreadArrays } from \"tslib\";\r\nimport * as React from \"react\";\r\n/**\r\n * An Observable implementation that will track a set of subscribers and supports\r\n * notifications when the underlying system changes.\r\n */\r\nvar Observable = /** @class */ (function () {\r\n    function Observable() {\r\n        this.observers = {};\r\n        this.subscriberCount = 0;\r\n    }\r\n    /**\r\n     * notify is used to send the event to all subscribers that have signed up for this events\r\n     * action. This means they have subscribed directly to this action, or to all actions.\r\n     * If the caller requested the event be persisted the event will be fired in order to new\r\n     * subscribers as well when they subscribe.\r\n     *\r\n     * @param value - The object that represents the event data.\r\n     *\r\n     * @param action - The action that happened on this observable to produce the event.\r\n     *\r\n     * @param persistEvent - Optional value that determines if all future subscribers will\r\n     *  recieve the event as well.\r\n     */\r\n    Observable.prototype.notify = function (value, action, persistEvent) {\r\n        var executeObserverAction = function (observer, value, action) {\r\n            try {\r\n                observer(value, action);\r\n            }\r\n            catch (ex) {\r\n                console.warn(ex);\r\n                if (ex && typeof ErrorEvent === \"function\") {\r\n                    window.dispatchEvent(new ErrorEvent(\"error\", {\r\n                        error: ex,\r\n                        filename: \"Observable.ts\",\r\n                        message: ex.message\r\n                    }));\r\n                }\r\n            }\r\n        };\r\n        // NOTE: We need to make a copy of the observers since they may change during notification.\r\n        if (this.observers[action]) {\r\n            var observers = this.observers[action].slice();\r\n            for (var observerIndex = 0; observerIndex < observers.length; observerIndex++) {\r\n                executeObserverAction(observers[observerIndex], value, action);\r\n            }\r\n        }\r\n        if (this.observers[\"\"]) {\r\n            var observers = this.observers[\"\"].slice();\r\n            for (var observerIndex = 0; observerIndex < observers.length; observerIndex++) {\r\n                executeObserverAction(observers[observerIndex], value, action);\r\n            }\r\n        }\r\n        // If the caller wants this event sent to all subscribers, even future ones, track it.\r\n        if (persistEvent) {\r\n            if (!this.events) {\r\n                this.events = [];\r\n            }\r\n            this.events.push({ action: action, value: value });\r\n        }\r\n    };\r\n    Observable.prototype.subscribe = function (observer, action) {\r\n        action = action || \"\";\r\n        if (!this.observers[action]) {\r\n            this.observers[action] = [];\r\n        }\r\n        this.observers[action].push(observer);\r\n        this.subscriberCount++;\r\n        // Fire the callback for any events that were persisted when they were sent.\r\n        if (this.events) {\r\n            for (var _i = 0, _a = this.events; _i < _a.length; _i++) {\r\n                var event_1 = _a[_i];\r\n                if (!action || event_1.action === action) {\r\n                    observer(event_1.value, event_1.action);\r\n                }\r\n            }\r\n        }\r\n        return observer;\r\n    };\r\n    Observable.prototype.unsubscribe = function (observer, action) {\r\n        action = action || \"\";\r\n        if (this.observers[action]) {\r\n            var observerIndex = this.observers[action].indexOf(observer);\r\n            if (observerIndex >= 0) {\r\n                this.observers[action].splice(observerIndex, 1);\r\n                this.subscriberCount--;\r\n            }\r\n        }\r\n    };\r\n    return Observable;\r\n}());\r\nexport { Observable };\r\nexport var ObservableLike;\r\n(function (ObservableLike) {\r\n    /**\r\n     * Check whether the specified object is an observable or not.\r\n     *\r\n     * @param observableLike Object to perform observable check.\r\n     */\r\n    function isObservable(observableLike) {\r\n        return observableLike && typeof observableLike.subscribe === \"function\";\r\n    }\r\n    ObservableLike.isObservable = isObservable;\r\n    function getValue(observableLike) {\r\n        if (isObservable(observableLike)) {\r\n            return observableLike.value;\r\n        }\r\n        return observableLike;\r\n    }\r\n    ObservableLike.getValue = getValue;\r\n    /**\r\n     * Subscribes to the specified object if it is an observable.\r\n     *\r\n     * @param observableLike Object to subscribe its value change if applicable.\r\n     * @param observer Delegate to be executed when the underlying data changes.\r\n     * @param action Optional argument that allows the consumer to supply a action\r\n     *  with the delegate. If the action is supplied only those actions are delievered,\r\n     *  while all actions are delivered is no action is supplied.\r\n     * @returns observer\r\n     */\r\n    function subscribe(observableLike, observer, action) {\r\n        if (isObservable(observableLike)) {\r\n            return observableLike.subscribe(observer, action);\r\n        }\r\n        return function () { };\r\n    }\r\n    ObservableLike.subscribe = subscribe;\r\n    /**\r\n     * Unsubscribes from the specified object if it is an observable.\r\n     *\r\n     * @param observableLike Object to subscribe its value change if applicable.\r\n     * @param observer Delegate to be executed when the underlying data changes.\r\n     * @param action Optional argument that allows the consumer to supply a action\r\n     *  with the delegate. If the action is supplied only those actions are delievered,\r\n     *  while all actions are delivered is no action is supplied.\r\n     */\r\n    function unsubscribe(observableLike, observer, action) {\r\n        if (isObservable(observableLike)) {\r\n            observableLike.unsubscribe(observer, action);\r\n        }\r\n    }\r\n    ObservableLike.unsubscribe = unsubscribe;\r\n})(ObservableLike || (ObservableLike = {}));\r\nvar ObservableValue = /** @class */ (function (_super) {\r\n    __extends(ObservableValue, _super);\r\n    function ObservableValue(value) {\r\n        var _this = _super.call(this) || this;\r\n        _this.v = value;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(ObservableValue.prototype, \"value\", {\r\n        get: function () {\r\n            return this.v;\r\n        },\r\n        set: function (value) {\r\n            this.v = value;\r\n            this.notify(this.v, \"set\");\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return ObservableValue;\r\n}(Observable));\r\nexport { ObservableValue };\r\n/**\r\n * An ObservableObject can be used to key a named collection of properties\r\n * and offer an observable endpoint.\r\n */\r\nvar ObservableObject = /** @class */ (function (_super) {\r\n    __extends(ObservableObject, _super);\r\n    function ObservableObject() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.objects = {};\r\n        return _this;\r\n    }\r\n    ObservableObject.prototype.add = function (objectName, objectDefinition) {\r\n        if (!this.objects.hasOwnProperty(objectName)) {\r\n            this.objects[objectName] = objectDefinition;\r\n            this.notify({ key: objectName, value: objectDefinition }, \"add\");\r\n        }\r\n    };\r\n    ObservableObject.prototype.get = function (objectName) {\r\n        return this.objects[objectName];\r\n    };\r\n    ObservableObject.prototype.set = function (objectName, objectDefinition) {\r\n        if (this.objects.hasOwnProperty(objectName)) {\r\n            this.objects[objectName] = objectDefinition;\r\n            this.notify({ key: objectName, value: objectDefinition }, \"replace\");\r\n        }\r\n        else {\r\n            this.add(objectName, objectDefinition);\r\n        }\r\n    };\r\n    ObservableObject.prototype.keys = function () {\r\n        return Object.keys(this.objects);\r\n    };\r\n    return ObservableObject;\r\n}(Observable));\r\nexport { ObservableObject };\r\n/**\r\n * EventTypes:\r\n *  change - { changedItems, index }\r\n *  push - {addedItems, index }\r\n *  pop - { index, removedItems}\r\n *  removeAll - {index, removedItems }\r\n *  splice - { addedItems, index, removedItems }\r\n */\r\nvar ObservableArray = /** @class */ (function (_super) {\r\n    __extends(ObservableArray, _super);\r\n    function ObservableArray(items) {\r\n        if (items === void 0) { items = []; }\r\n        var _this = _super.call(this) || this;\r\n        _this.internalItems = items || [];\r\n        return _this;\r\n    }\r\n    ObservableArray.prototype.change = function (start) {\r\n        var _a;\r\n        var items = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            items[_i - 1] = arguments[_i];\r\n        }\r\n        (_a = this.internalItems).splice.apply(_a, __spreadArrays([start, items.length], items));\r\n        this.notify({ index: start, changedItems: items }, \"change\");\r\n        return items.length;\r\n    };\r\n    Object.defineProperty(ObservableArray.prototype, \"length\", {\r\n        get: function () {\r\n            return this.internalItems.length;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ObservableArray.prototype.push = function () {\r\n        var _a;\r\n        var items = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            items[_i] = arguments[_i];\r\n        }\r\n        if (items.length) {\r\n            var index = this.internalItems.length;\r\n            (_a = this.internalItems).push.apply(_a, items);\r\n            this.notify({ addedItems: items, index: index }, \"push\");\r\n        }\r\n        return items.length;\r\n    };\r\n    ObservableArray.prototype.pop = function () {\r\n        var item = this.internalItems.pop();\r\n        if (item !== undefined) {\r\n            this.notify({ index: this.internalItems.length, removedItems: [item] }, \"pop\");\r\n        }\r\n        return item;\r\n    };\r\n    ObservableArray.prototype.removeAll = function (filter) {\r\n        var removedItems = [];\r\n        var remainingItems = [];\r\n        for (var _i = 0, _a = this.internalItems; _i < _a.length; _i++) {\r\n            var item = _a[_i];\r\n            if (!filter || filter(item)) {\r\n                removedItems.push(item);\r\n            }\r\n            else {\r\n                remainingItems.push(item);\r\n            }\r\n        }\r\n        if (removedItems.length > 0) {\r\n            this.internalItems.splice(0, this.internalItems.length);\r\n            for (var _b = 0, remainingItems_1 = remainingItems; _b < remainingItems_1.length; _b++) {\r\n                var item = remainingItems_1[_b];\r\n                this.internalItems.push(item);\r\n            }\r\n            this.notify({ index: 0, removedItems: removedItems }, \"removeAll\");\r\n        }\r\n        return removedItems;\r\n    };\r\n    ObservableArray.prototype.splice = function (start, deleteCount) {\r\n        var _a;\r\n        var itemsToAdd = [];\r\n        for (var _i = 2; _i < arguments.length; _i++) {\r\n            itemsToAdd[_i - 2] = arguments[_i];\r\n        }\r\n        var removedItems = (_a = this.internalItems).splice.apply(_a, __spreadArrays([start, deleteCount], itemsToAdd));\r\n        this.notify({ addedItems: itemsToAdd, index: start, removedItems: removedItems }, \"splice\");\r\n        return removedItems;\r\n    };\r\n    Object.defineProperty(ObservableArray.prototype, \"value\", {\r\n        get: function () {\r\n            return this.internalItems;\r\n        },\r\n        set: function (items) {\r\n            // Preserve the original array, but avoid the \"...\" arguments issue with splice/push\r\n            var removedItems;\r\n            if (items === this.internalItems) {\r\n                // Special case for someone passing us the same internal array that we are already using\r\n                // We don't need to modify the internalItems. The \"removedItems\" in the event is\r\n                // not going to be accurate in the case that someone modified this internal array\r\n                // outside of the observable -- we won't know the prior state in that case.\r\n                removedItems = this.internalItems;\r\n            }\r\n            else {\r\n                // Clear out the existing items\r\n                removedItems = this.internalItems.slice();\r\n                this.internalItems.length = 0;\r\n                // Add all new items\r\n                if (items.length) {\r\n                    for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {\r\n                        var item = items_1[_i];\r\n                        this.internalItems.push(item);\r\n                    }\r\n                }\r\n            }\r\n            this.notify({ addedItems: items, index: 0, removedItems: removedItems }, \"splice\");\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return ObservableArray;\r\n}(Observable));\r\nexport { ObservableArray };\r\n/**\r\n * An Observable Collection takes an arry of arrays or observable arrays\r\n * and flattens out the items into a single readonly observable array\r\n * (with all the underlying array values aggregated together).\r\n *\r\n * This handles subscribing to any underlying observable arrays and\r\n * updating the aggregate array as appropriate (and notifying subscribers)\r\n */\r\nvar ObservableCollection = /** @class */ (function (_super) {\r\n    __extends(ObservableCollection, _super);\r\n    function ObservableCollection() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.collections = [];\r\n        _this.items = [];\r\n        return _this;\r\n    }\r\n    Object.defineProperty(ObservableCollection.prototype, \"length\", {\r\n        get: function () {\r\n            if (!this.subscriberCount) {\r\n                this.recalculateItems();\r\n            }\r\n            return this.items.length;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ObservableCollection.prototype, \"value\", {\r\n        get: function () {\r\n            if (!this.subscriberCount) {\r\n                this.recalculateItems();\r\n            }\r\n            return this.items;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Adds an additional collection of items to the end of the array\r\n     *\r\n     * @param collection Array of items or an observable array of items\r\n     * @params transformItems Delegate to process each item that is pulled from the given collection\r\n     */\r\n    ObservableCollection.prototype.push = function (collection, transformItems) {\r\n        var collectionEntry;\r\n        var pushedItems;\r\n        if (ObservableLike.isObservable(collection)) {\r\n            var observable = collection;\r\n            var subscriber = this.getSubscriber(this.collections.length, transformItems);\r\n            collectionEntry = { observable: observable, subscriber: subscriber, transformItems: transformItems, items: [] };\r\n            pushedItems = observable.value;\r\n            if (this.subscriberCount) {\r\n                ObservableLike.subscribe(collectionEntry.observable, subscriber);\r\n            }\r\n        }\r\n        else if (collection.length) {\r\n            pushedItems = collection;\r\n            collectionEntry = { items: this.transformItems(pushedItems, transformItems) };\r\n        }\r\n        if (collectionEntry) {\r\n            this.collections.push(collectionEntry);\r\n            if (this.subscriberCount && pushedItems.length) {\r\n                var newItems = this.transformItems(pushedItems, transformItems);\r\n                for (var _i = 0, newItems_1 = newItems; _i < newItems_1.length; _i++) {\r\n                    var newItem = newItems_1[_i];\r\n                    this.items.push(newItem);\r\n                }\r\n                this.notify({ addedItems: newItems, index: this.items.length - newItems.length }, \"push\");\r\n            }\r\n        }\r\n    };\r\n    ObservableCollection.prototype.subscribe = function (observer, action) {\r\n        var subscription = _super.prototype.subscribe.call(this, observer, action);\r\n        if (this.subscriberCount === 1) {\r\n            this.recalculateItems();\r\n            for (var _i = 0, _a = this.collections; _i < _a.length; _i++) {\r\n                var collection = _a[_i];\r\n                if (collection.subscriber) {\r\n                    collection.observable.subscribe(collection.subscriber);\r\n                }\r\n            }\r\n        }\r\n        return subscription;\r\n    };\r\n    ObservableCollection.prototype.unsubscribe = function (observer, action) {\r\n        _super.prototype.unsubscribe.call(this, observer, action);\r\n        if (this.subscriberCount === 0) {\r\n            for (var _i = 0, _a = this.collections; _i < _a.length; _i++) {\r\n                var collection = _a[_i];\r\n                if (collection.subscriber) {\r\n                    collection.observable.unsubscribe(collection.subscriber);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Recalculate items. This is necessary while we work without subscribers, as we're not listening to changes in observable inner collections.\r\n     * Once the first subscriber joins, items collection will be in sync real-time.\r\n     */\r\n    ObservableCollection.prototype.recalculateItems = function () {\r\n        this.items.length = 0;\r\n        for (var _i = 0, _a = this.collections; _i < _a.length; _i++) {\r\n            var collection = _a[_i];\r\n            if (collection.observable) {\r\n                collection.items = this.transformItems(collection.observable.value, collection.transformItems);\r\n            }\r\n            for (var _b = 0, _c = collection.items; _b < _c.length; _b++) {\r\n                var item = _c[_b];\r\n                this.items.push(item);\r\n            }\r\n        }\r\n    };\r\n    ObservableCollection.prototype.transformItems = function (inputItems, transformInput) {\r\n        var transformedItems;\r\n        if (!inputItems) {\r\n            transformedItems = [];\r\n        }\r\n        else if (transformInput) {\r\n            transformedItems = [];\r\n            for (var _i = 0, inputItems_1 = inputItems; _i < inputItems_1.length; _i++) {\r\n                var inputItem = inputItems_1[_i];\r\n                var transformedItem = transformInput(inputItem);\r\n                if (transformedItem !== undefined) {\r\n                    transformedItems.push(transformedItem);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            transformedItems = inputItems;\r\n        }\r\n        return transformedItems;\r\n    };\r\n    ObservableCollection.prototype.getSubscriber = function (collectionIndex, transformInput) {\r\n        var _this = this;\r\n        return function (args) {\r\n            var _a;\r\n            // Find the index in our aggregate array\r\n            var index = args.index;\r\n            for (var i = 0; i < collectionIndex; i++) {\r\n                index += _this.collections[i].items.length;\r\n            }\r\n            if (args.changedItems) {\r\n                // Handle change event\r\n                var changedItems = _this.transformItems(args.changedItems, transformInput);\r\n                (_a = _this.items).splice.apply(_a, __spreadArrays([index, args.changedItems.length], changedItems));\r\n                _this.notify({ changedItems: changedItems, index: index }, \"change\");\r\n            }\r\n            else {\r\n                // Handle splice, push, pop events\r\n                var removedItems = _this.transformItems(args.removedItems, transformInput);\r\n                var addedItems = _this.transformItems(args.addedItems, transformInput);\r\n                // We would normally just call splice here with 3 arguments, but splice takes a \"...\" argument for added items\r\n                // which passes array elements on the stack and is therefore limited (to 32K/64K on some browsers)\r\n                // Remove the removedItems first\r\n                _this.items.splice(index, removedItems.length);\r\n                // Slice-off any remaining items past where we want to insert\r\n                var endItems = _this.items.splice(index);\r\n                // Push the addedItems followed by the endItems that we just removed\r\n                for (var _i = 0, addedItems_1 = addedItems; _i < addedItems_1.length; _i++) {\r\n                    var item = addedItems_1[_i];\r\n                    _this.items.push(item);\r\n                }\r\n                for (var _b = 0, endItems_1 = endItems; _b < endItems_1.length; _b++) {\r\n                    var item = endItems_1[_b];\r\n                    _this.items.push(item);\r\n                }\r\n                _this.notify({ removedItems: removedItems, addedItems: addedItems, index: index }, \"splice\");\r\n            }\r\n        };\r\n    };\r\n    return ObservableCollection;\r\n}(Observable));\r\nexport { ObservableCollection };\r\nvar ReadyableObservableArray = /** @class */ (function (_super) {\r\n    __extends(ReadyableObservableArray, _super);\r\n    function ReadyableObservableArray(items, ready) {\r\n        if (items === void 0) { items = []; }\r\n        if (ready === void 0) { ready = false; }\r\n        var _this = _super.call(this, items) || this;\r\n        _this.ready = new ObservableValue(ready);\r\n        return _this;\r\n    }\r\n    return ReadyableObservableArray;\r\n}(ObservableArray));\r\nexport { ReadyableObservableArray };\r\n/**\r\n * React Hooks extension that allows the consumer to track Observables with a useState like\r\n * hooks API.\r\n *\r\n * @param initialState Initial value for the state, or a function that will resolve the value\r\n * the when the value is initialized.\r\n */\r\nexport function useObservable(initialState) {\r\n    var underlyingState = React.useState(initialState)[0];\r\n    var observable = React.useState(function () { return new ObservableValue(underlyingState); })[0];\r\n    var updateState = function (updatedState) {\r\n        if (typeof updatedState === \"function\") {\r\n            observable.value = updatedState(observable.value);\r\n        }\r\n        else {\r\n            observable.value = updatedState;\r\n        }\r\n    };\r\n    return [observable, updateState];\r\n}\r\n/**\r\n * React Hooks extension that allows the consmer to track ObservableArrays with a useState like\r\n * hooks API.\r\n *\r\n * @param initialState Initial value for the state, or a function that will resolve the value\r\n * the when the value is initialized.\r\n */\r\nexport function useObservableArray(initialState) {\r\n    var underlyingState = React.useState(initialState)[0];\r\n    var reactState = React.useState(new ObservableArray(underlyingState));\r\n    var updateState = function (updatedState) {\r\n        if (typeof updatedState === \"function\") {\r\n            reactState[0].value = updatedState(reactState[0].value);\r\n        }\r\n        else {\r\n            reactState[0].value = updatedState;\r\n        }\r\n    };\r\n    return [reactState[0], updateState];\r\n}\r\n/**\r\n * React Hooks extension that provides a constant reference to an ObservableValue which will update\r\n * based on another observable.\r\n *\r\n * @remarks\r\n * The subscription will be safely unsubscribed any time:\r\n * - The source observable points to a new object\r\n * - The callback dependencies array changes\r\n * - The component is unmounted\r\n *\r\n * @param sourceObservable\r\n * @param getDerivedValue\r\n * @param callbackDependencies\r\n */\r\nexport function useDerivedObservable(sourceObservable, getDerivedValue, callbackDependencies) {\r\n    var initialValue = getDerivedValue(sourceObservable.value);\r\n    var _a = useObservable(initialValue), observable = _a[0], setValue = _a[1];\r\n    var getDerivedValueCallback = React.useCallback(getDerivedValue, callbackDependencies);\r\n    useSubscription(sourceObservable, function (newValue) {\r\n        var derivedValue = getDerivedValueCallback(newValue);\r\n        setValue(derivedValue);\r\n    }, callbackDependencies);\r\n    return observable;\r\n}\r\n/**\r\n * React Hooks extension that fires a callback whenever the provided observable changes.\r\n *\r\n * @remarks\r\n * The subscription will be safely unsubscribed any time:\r\n * - The source observable points to a new object\r\n * - The callback dependencies array changes\r\n * - The component is unmounted\r\n *\r\n * @param sourceObservable\r\n * @param callbackFn\r\n * @param callbackDependencies\r\n */\r\nexport function useSubscription(sourceObservable, callbackFn, callbackDependencies) {\r\n    if (callbackDependencies === void 0) { callbackDependencies = []; }\r\n    var callback = React.useCallback(callbackFn, callbackDependencies);\r\n    React.useEffect(function () {\r\n        sourceObservable.subscribe(callback);\r\n        return function () { return sourceObservable.unsubscribe(callback); };\r\n    }, [sourceObservable, callback]);\r\n}\r\n/**\r\n * React Hooks extension that debounces the firing of a callback whenever the provided observable changes.\r\n *\r\n * @remarks\r\n * The subscription will be safely unsubscribed any time:\r\n * - The source observable points to a new object\r\n * - The timeout value changes\r\n * - The callback dependencies array changes\r\n * - The component is unmounted\r\n *\r\n * @param sourceObservable\r\n * @param callbackFn\r\n * @param callbackDependencies\r\n */\r\nexport function useDebouncedSubscription(sourceObservable, debounceMs, callbackFn, callbackDependencies) {\r\n    if (callbackDependencies === void 0) { callbackDependencies = []; }\r\n    var timeoutRef = React.useRef(null);\r\n    useSubscription(sourceObservable, function (value) {\r\n        if (timeoutRef.current) {\r\n            clearTimeout(timeoutRef.current);\r\n        }\r\n        timeoutRef.current = setTimeout(function () {\r\n            callbackFn(value);\r\n            timeoutRef.current = null;\r\n        }, debounceMs);\r\n    }, __spreadArrays([debounceMs], callbackDependencies));\r\n}\r\n"]},"metadata":{},"sourceType":"module"}