{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport \"../../CommonImports\";\nimport \"../../Core/core.css\";\nimport \"./Tooltip.css\";\nimport * as React from \"react\";\nimport { Callout } from '../../Callout';\nimport { FocusWithin } from '../../FocusWithin';\nimport { MouseWithin } from '../../MouseWithin';\nimport { css, getFocusVisible, getSafeId, KeyCode, Mouse } from '../../Util';\nimport { Location } from '../../Utilities/Position';\nexport var TooltipStatus;\n\n(function (TooltipStatus) {\n  TooltipStatus[TooltipStatus[\"hidden\"] = 0] = \"hidden\";\n  TooltipStatus[TooltipStatus[\"visible\"] = 1] = \"visible\";\n  TooltipStatus[TooltipStatus[\"fadingout\"] = 2] = \"fadingout\";\n})(TooltipStatus || (TooltipStatus = {}));\n\nvar tooltipId = 1;\n\nvar Tooltip =\n/** @class */\nfunction (_super) {\n  __extends(Tooltip, _super);\n\n  function Tooltip(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.contentRef = React.createRef();\n    _this.tooltipId = \"tooltip-\" + tooltipId++;\n    _this.focus = false;\n    _this.mouse = false;\n\n    _this.showTooltip = function (event) {\n      var anchorElement = event.currentTarget;\n\n      if (_this.shouldShowTooltip(anchorElement)) {\n        // If no anchorOrigin was specified use the Mouse.position when we show the toolip.\n        var anchorPoint = void 0;\n\n        if (!_this.props.anchorOrigin) {\n          anchorPoint = Mouse.position;\n        }\n\n        _this.mouse = true;\n        document.addEventListener(\"keydown\", _this.onKeyDown);\n\n        _this.setState({\n          anchorElement: anchorElement,\n          anchorOffset: {\n            horizontal: 8,\n            vertical: 8\n          },\n          anchorOrigin: {\n            horizontal: Location.center,\n            vertical: Location.end\n          },\n          anchorPoint: anchorPoint,\n          innerText: _this.props.overflowOnly && !_this.props.text ? anchorElement.innerText : undefined,\n          tooltipStatus: TooltipStatus.visible,\n          tooltipOrigin: {\n            horizontal: Location.start,\n            vertical: Location.start\n          }\n        });\n      }\n    };\n\n    _this.closeTooltip = function () {\n      if (!(_this.focus && getFocusVisible()) && _this.state.tooltipStatus === TooltipStatus.visible) {\n        _this.mouse = false;\n        document.removeEventListener(\"keydown\", _this.onKeyDown);\n\n        _this.setState({\n          tooltipStatus: _this.getDismissStatus()\n        });\n      }\n    };\n\n    _this.onKeyDown = function (event) {\n      var _a;\n\n      if (event.which === KeyCode.escape && _this.state.tooltipStatus === TooltipStatus.visible) {\n        _this.closeTooltip();\n      }\n\n      if (event.which === KeyCode.ctrl && _this.state.tooltipStatus === TooltipStatus.visible) {\n        var container = _this.contentRef.current;\n        var selectionNode = (_a = window.getSelection()) === null || _a === void 0 ? void 0 : _a.anchorNode;\n        var hasSelectionInTooltip = container && selectionNode && container.contains(selectionNode); // Ctrl keystroke anywhere will dismiss the callout as per MAS 1.4.13,\n        // except if user has selected something inside, in which case we allow Ctrl-C.\n\n        if (!hasSelectionInTooltip) {\n          _this.closeTooltip();\n        }\n      }\n    };\n\n    _this.onAnimationEnd = function () {\n      if (_this.state.tooltipStatus === TooltipStatus.fadingout) {\n        _this.setState({\n          tooltipStatus: TooltipStatus.hidden\n        });\n      }\n    };\n\n    _this.getDismissStatus = function () {\n      return _this.props.disabled ? TooltipStatus.hidden : TooltipStatus.fadingout;\n    };\n\n    _this.shouldShowTooltip = function (anchorElement) {\n      if (_this.state.tooltipStatus !== TooltipStatus.hidden) {\n        return false;\n      } // If the tooltip only appears when the anchorElement overflows its parent then\n      // we need to check on mouse enter.\n\n\n      if (_this.props.overflowOnly && !_this.overflowDetected(anchorElement)) {\n        return false;\n      } // Dont show the tooltip if there is not content to show.\n\n\n      if (!(_this.props.text || _this.props.renderContent || anchorElement.innerText && _this.props.overflowOnly)) {\n        return false;\n      }\n\n      return !_this.props.disabled;\n    };\n\n    _this.overflowDetected = props.overflowDetected || overflowDetected;\n    _this.state = {\n      tooltipStatus: TooltipStatus.hidden\n    };\n    return _this;\n  }\n\n  Tooltip.prototype.render = function () {\n    var _this = this;\n\n    return React.createElement(MouseWithin, {\n      leaveDelay: 50,\n      enterDelay: this.props.delayMs,\n      onMouseLeave: this.closeTooltip,\n      onMouseEnter: this.showTooltip\n    }, function (mouseWithinEvents) {\n      var child = React.Children.only(_this.props.children);\n      var id = _this.props.id || _this.tooltipId;\n      var showTooltip = _this.state.tooltipStatus !== TooltipStatus.hidden && !_this.props.disabled && _this.state.anchorElement; // Save the existing events we will potentially proxy.\n\n      var existingMouseEnter = child.props.onMouseEnter;\n      var existingMouseLeave = child.props.onMouseLeave;\n      var existingKeyDown = child.props.onKeyDown;\n      var existingBlur;\n      var existingFocus;\n\n      var onMouseEnter = function (event) {\n        if (mouseWithinEvents.onMouseEnter) {\n          mouseWithinEvents.onMouseEnter(event);\n        }\n\n        if (existingMouseEnter) {\n          existingMouseEnter(event);\n        }\n      };\n\n      var onMouseLeave = function (event) {\n        if (mouseWithinEvents.onMouseLeave) {\n          mouseWithinEvents.onMouseLeave(event);\n        }\n\n        if (existingMouseLeave) {\n          existingMouseLeave(event);\n        }\n      };\n\n      var onKeyDown = function (event) {\n        if (event.which === KeyCode.escape && showTooltip) {\n          _this.setState({\n            tooltipStatus: TooltipStatus.hidden\n          });\n\n          event.preventDefault();\n        }\n\n        if (existingKeyDown) {\n          existingKeyDown(event);\n        }\n      }; // to not let consumers have to care about an implementation detail, wrap\n      // the tooltip id in getSafeId and use that as the aria-describedBy property\n      // on the child.\n\n\n      var ariaDescribedById = _this.props.addAriaDescribedBy && _this.state.tooltipStatus !== TooltipStatus.hidden ? getSafeId(id) : undefined;\n\n      var childProps = __assign(__assign({}, child.props), {\n        onMouseEnter: onMouseEnter,\n        onMouseLeave: onMouseLeave,\n        onKeyDown: onKeyDown\n      });\n\n      if (childProps[\"aria-describedby\"] === undefined) {\n        childProps[\"aria-describedby\"] = ariaDescribedById;\n      }\n\n      var clonedChild = React.cloneElement(child, childProps, child.props.children); // If this tooltip should become visible when focus is within the component add the focus tracking.\n\n      if (_this.props.showOnFocus && (_this.props.text || _this.props.renderContent || _this.props.overflowOnly)) {\n        existingBlur = child.props.onBlur;\n        existingFocus = child.props.onFocus;\n\n        var onBlur = function () {\n          _this.focus = false;\n\n          if (!_this.mouse) {\n            _this.closeTooltip();\n          }\n\n          if (existingBlur) {\n            existingBlur();\n          }\n        };\n\n        var onFocus = function (event) {\n          var anchorElement = event.currentTarget;\n\n          if (_this.shouldShowTooltip(anchorElement)) {\n            _this.focus = true;\n            getFocusVisible() && _this.setState({\n              anchorElement: event.target,\n              anchorOffset: {\n                horizontal: 0,\n                vertical: 8\n              },\n              anchorOrigin: {\n                horizontal: Location.center,\n                vertical: Location.end\n              },\n              anchorPoint: undefined,\n              innerText: _this.props.overflowOnly && !_this.props.text ? anchorElement.innerText : undefined,\n              tooltipStatus: TooltipStatus.visible,\n              tooltipOrigin: {\n                horizontal: Location.center,\n                vertical: Location.start\n              }\n            });\n          }\n\n          if (existingFocus) {\n            existingFocus(event);\n          }\n        };\n\n        clonedChild = React.createElement(FocusWithin, {\n          onBlur: onBlur,\n          onFocus: onFocus,\n          updateStateOnFocusChange: false\n        }, clonedChild);\n      }\n\n      return React.createElement(React.Fragment, null, clonedChild, showTooltip ? React.createElement(Callout, {\n        anchorElement: _this.state.anchorElement,\n        anchorOffset: _this.props.anchorOffset || _this.state.anchorOffset,\n        anchorOrigin: _this.props.anchorOrigin || _this.state.anchorOrigin,\n        anchorPoint: _this.state.anchorPoint,\n        calloutOrigin: _this.props.tooltipOrigin || _this.state.tooltipOrigin,\n        className: css(_this.props.className, \"bolt-tooltip\", _this.state.tooltipStatus === TooltipStatus.fadingout && \"bolt-tooltip-fade-out\"),\n        fixedLayout: _this.props.fixedLayout,\n        id: id,\n        key: id,\n        onAnimationEnd: _this.onAnimationEnd,\n        onMouseEnter: mouseWithinEvents.onMouseEnter,\n        onMouseLeave: mouseWithinEvents.onMouseLeave,\n        portalProps: {\n          className: \"bolt-tooltip-portal\"\n        },\n        contentRef: _this.contentRef,\n        role: \"tooltip\"\n      }, React.createElement(\"div\", {\n        className: \"bolt-tooltip-content body-m\"\n      }, _this.props.renderContent && _this.props.renderContent() || _this.props.text || _this.state.innerText)) : null);\n    });\n  };\n\n  Tooltip.prototype.componentWillUnmount = function () {\n    document.removeEventListener(\"keydown\", this.onKeyDown);\n  };\n\n  Tooltip.defaultProps = {\n    delayMs: 250,\n    showOnFocus: true\n  };\n  return Tooltip;\n}(React.Component);\n\nexport { Tooltip };\n\nfunction overflowDetected(anchorElement) {\n  return anchorElement.scrollWidth > Math.ceil(anchorElement.offsetWidth);\n}","map":{"version":3,"sources":["/Users/ayounghosh/Downloads/Create_Work_Item_Azure_Devops/Front_End/node_modules/azure-devops-ui/Components/TooltipEx/Tooltip.js"],"names":["__assign","__extends","React","Callout","FocusWithin","MouseWithin","css","getFocusVisible","getSafeId","KeyCode","Mouse","Location","TooltipStatus","tooltipId","Tooltip","_super","props","_this","call","contentRef","createRef","focus","mouse","showTooltip","event","anchorElement","currentTarget","shouldShowTooltip","anchorPoint","anchorOrigin","position","document","addEventListener","onKeyDown","setState","anchorOffset","horizontal","vertical","center","end","innerText","overflowOnly","text","undefined","tooltipStatus","visible","tooltipOrigin","start","closeTooltip","state","removeEventListener","getDismissStatus","_a","which","escape","ctrl","container","current","selectionNode","window","getSelection","anchorNode","hasSelectionInTooltip","contains","onAnimationEnd","fadingout","hidden","disabled","overflowDetected","renderContent","prototype","render","createElement","leaveDelay","enterDelay","delayMs","onMouseLeave","onMouseEnter","mouseWithinEvents","child","Children","only","children","id","existingMouseEnter","existingMouseLeave","existingKeyDown","existingBlur","existingFocus","preventDefault","ariaDescribedById","addAriaDescribedBy","childProps","clonedChild","cloneElement","showOnFocus","onBlur","onFocus","target","updateStateOnFocusChange","Fragment","calloutOrigin","className","fixedLayout","key","portalProps","role","componentWillUnmount","defaultProps","Component","scrollWidth","Math","ceil","offsetWidth"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,SAAnB,QAAoC,OAApC;AACA,OAAO,qBAAP;AACA,OAAO,qBAAP;AACA,OAAO,eAAP;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,SAASC,OAAT,QAAwB,eAAxB;AACA,SAASC,WAAT,QAA4B,mBAA5B;AACA,SAASC,WAAT,QAA4B,mBAA5B;AACA,SAASC,GAAT,EAAcC,eAAd,EAA+BC,SAA/B,EAA0CC,OAA1C,EAAmDC,KAAnD,QAAgE,YAAhE;AACA,SAASC,QAAT,QAAyB,0BAAzB;AACA,OAAO,IAAIC,aAAJ;;AACP,CAAC,UAAUA,aAAV,EAAyB;AACtBA,EAAAA,aAAa,CAACA,aAAa,CAAC,QAAD,CAAb,GAA0B,CAA3B,CAAb,GAA6C,QAA7C;AACAA,EAAAA,aAAa,CAACA,aAAa,CAAC,SAAD,CAAb,GAA2B,CAA5B,CAAb,GAA8C,SAA9C;AACAA,EAAAA,aAAa,CAACA,aAAa,CAAC,WAAD,CAAb,GAA6B,CAA9B,CAAb,GAAgD,WAAhD;AACH,CAJD,EAIGA,aAAa,KAAKA,aAAa,GAAG,EAArB,CAJhB;;AAKA,IAAIC,SAAS,GAAG,CAAhB;;AACA,IAAIC,OAAO;AAAG;AAAe,UAAUC,MAAV,EAAkB;AAC3Cd,EAAAA,SAAS,CAACa,OAAD,EAAUC,MAAV,CAAT;;AACA,WAASD,OAAT,CAAiBE,KAAjB,EAAwB;AACpB,QAAIC,KAAK,GAAGF,MAAM,CAACG,IAAP,CAAY,IAAZ,EAAkBF,KAAlB,KAA4B,IAAxC;;AACAC,IAAAA,KAAK,CAACE,UAAN,GAAmBjB,KAAK,CAACkB,SAAN,EAAnB;AACAH,IAAAA,KAAK,CAACJ,SAAN,GAAkB,aAAaA,SAAS,EAAxC;AACAI,IAAAA,KAAK,CAACI,KAAN,GAAc,KAAd;AACAJ,IAAAA,KAAK,CAACK,KAAN,GAAc,KAAd;;AACAL,IAAAA,KAAK,CAACM,WAAN,GAAoB,UAAUC,KAAV,EAAiB;AACjC,UAAIC,aAAa,GAAGD,KAAK,CAACE,aAA1B;;AACA,UAAIT,KAAK,CAACU,iBAAN,CAAwBF,aAAxB,CAAJ,EAA4C;AACxC;AACA,YAAIG,WAAW,GAAG,KAAK,CAAvB;;AACA,YAAI,CAACX,KAAK,CAACD,KAAN,CAAYa,YAAjB,EAA+B;AAC3BD,UAAAA,WAAW,GAAGlB,KAAK,CAACoB,QAApB;AACH;;AACDb,QAAAA,KAAK,CAACK,KAAN,GAAc,IAAd;AACAS,QAAAA,QAAQ,CAACC,gBAAT,CAA0B,SAA1B,EAAqCf,KAAK,CAACgB,SAA3C;;AACAhB,QAAAA,KAAK,CAACiB,QAAN,CAAe;AACXT,UAAAA,aAAa,EAAEA,aADJ;AAEXU,UAAAA,YAAY,EAAE;AAAEC,YAAAA,UAAU,EAAE,CAAd;AAAiBC,YAAAA,QAAQ,EAAE;AAA3B,WAFH;AAGXR,UAAAA,YAAY,EAAE;AAAEO,YAAAA,UAAU,EAAEzB,QAAQ,CAAC2B,MAAvB;AAA+BD,YAAAA,QAAQ,EAAE1B,QAAQ,CAAC4B;AAAlD,WAHH;AAIXX,UAAAA,WAAW,EAAEA,WAJF;AAKXY,UAAAA,SAAS,EAAEvB,KAAK,CAACD,KAAN,CAAYyB,YAAZ,IAA4B,CAACxB,KAAK,CAACD,KAAN,CAAY0B,IAAzC,GAAgDjB,aAAa,CAACe,SAA9D,GAA0EG,SAL1E;AAMXC,UAAAA,aAAa,EAAEhC,aAAa,CAACiC,OANlB;AAOXC,UAAAA,aAAa,EAAE;AAAEV,YAAAA,UAAU,EAAEzB,QAAQ,CAACoC,KAAvB;AAA8BV,YAAAA,QAAQ,EAAE1B,QAAQ,CAACoC;AAAjD;AAPJ,SAAf;AASH;AACJ,KApBD;;AAqBA9B,IAAAA,KAAK,CAAC+B,YAAN,GAAqB,YAAY;AAC7B,UAAI,EAAE/B,KAAK,CAACI,KAAN,IAAed,eAAe,EAAhC,KAAuCU,KAAK,CAACgC,KAAN,CAAYL,aAAZ,KAA8BhC,aAAa,CAACiC,OAAvF,EAAgG;AAC5F5B,QAAAA,KAAK,CAACK,KAAN,GAAc,KAAd;AACAS,QAAAA,QAAQ,CAACmB,mBAAT,CAA6B,SAA7B,EAAwCjC,KAAK,CAACgB,SAA9C;;AACAhB,QAAAA,KAAK,CAACiB,QAAN,CAAe;AAAEU,UAAAA,aAAa,EAAE3B,KAAK,CAACkC,gBAAN;AAAjB,SAAf;AACH;AACJ,KAND;;AAOAlC,IAAAA,KAAK,CAACgB,SAAN,GAAkB,UAAUT,KAAV,EAAiB;AAC/B,UAAI4B,EAAJ;;AACA,UAAI5B,KAAK,CAAC6B,KAAN,KAAgB5C,OAAO,CAAC6C,MAAxB,IAAkCrC,KAAK,CAACgC,KAAN,CAAYL,aAAZ,KAA8BhC,aAAa,CAACiC,OAAlF,EAA2F;AACvF5B,QAAAA,KAAK,CAAC+B,YAAN;AACH;;AACD,UAAIxB,KAAK,CAAC6B,KAAN,KAAgB5C,OAAO,CAAC8C,IAAxB,IAAgCtC,KAAK,CAACgC,KAAN,CAAYL,aAAZ,KAA8BhC,aAAa,CAACiC,OAAhF,EAAyF;AACrF,YAAIW,SAAS,GAAGvC,KAAK,CAACE,UAAN,CAAiBsC,OAAjC;AACA,YAAIC,aAAa,GAAG,CAACN,EAAE,GAAGO,MAAM,CAACC,YAAP,EAAN,MAAiC,IAAjC,IAAyCR,EAAE,KAAK,KAAK,CAArD,GAAyD,KAAK,CAA9D,GAAkEA,EAAE,CAACS,UAAzF;AACA,YAAIC,qBAAqB,GAAGN,SAAS,IAAIE,aAAb,IAA8BF,SAAS,CAACO,QAAV,CAAmBL,aAAnB,CAA1D,CAHqF,CAIrF;AACA;;AACA,YAAI,CAACI,qBAAL,EAA4B;AACxB7C,UAAAA,KAAK,CAAC+B,YAAN;AACH;AACJ;AACJ,KAfD;;AAgBA/B,IAAAA,KAAK,CAAC+C,cAAN,GAAuB,YAAY;AAC/B,UAAI/C,KAAK,CAACgC,KAAN,CAAYL,aAAZ,KAA8BhC,aAAa,CAACqD,SAAhD,EAA2D;AACvDhD,QAAAA,KAAK,CAACiB,QAAN,CAAe;AACXU,UAAAA,aAAa,EAAEhC,aAAa,CAACsD;AADlB,SAAf;AAGH;AACJ,KAND;;AAOAjD,IAAAA,KAAK,CAACkC,gBAAN,GAAyB,YAAY;AACjC,aAAOlC,KAAK,CAACD,KAAN,CAAYmD,QAAZ,GAAuBvD,aAAa,CAACsD,MAArC,GAA8CtD,aAAa,CAACqD,SAAnE;AACH,KAFD;;AAGAhD,IAAAA,KAAK,CAACU,iBAAN,GAA0B,UAAUF,aAAV,EAAyB;AAC/C,UAAIR,KAAK,CAACgC,KAAN,CAAYL,aAAZ,KAA8BhC,aAAa,CAACsD,MAAhD,EAAwD;AACpD,eAAO,KAAP;AACH,OAH8C,CAI/C;AACA;;;AACA,UAAIjD,KAAK,CAACD,KAAN,CAAYyB,YAAZ,IAA4B,CAACxB,KAAK,CAACmD,gBAAN,CAAuB3C,aAAvB,CAAjC,EAAwE;AACpE,eAAO,KAAP;AACH,OAR8C,CAS/C;;;AACA,UAAI,EAAER,KAAK,CAACD,KAAN,CAAY0B,IAAZ,IAAoBzB,KAAK,CAACD,KAAN,CAAYqD,aAAhC,IAAkD5C,aAAa,CAACe,SAAd,IAA2BvB,KAAK,CAACD,KAAN,CAAYyB,YAA3F,CAAJ,EAA+G;AAC3G,eAAO,KAAP;AACH;;AACD,aAAO,CAACxB,KAAK,CAACD,KAAN,CAAYmD,QAApB;AACH,KAdD;;AAeAlD,IAAAA,KAAK,CAACmD,gBAAN,GAAyBpD,KAAK,CAACoD,gBAAN,IAA0BA,gBAAnD;AACAnD,IAAAA,KAAK,CAACgC,KAAN,GAAc;AACVL,MAAAA,aAAa,EAAEhC,aAAa,CAACsD;AADnB,KAAd;AAGA,WAAOjD,KAAP;AACH;;AACDH,EAAAA,OAAO,CAACwD,SAAR,CAAkBC,MAAlB,GAA2B,YAAY;AACnC,QAAItD,KAAK,GAAG,IAAZ;;AACA,WAAQf,KAAK,CAACsE,aAAN,CAAoBnE,WAApB,EAAiC;AAAEoE,MAAAA,UAAU,EAAE,EAAd;AAAkBC,MAAAA,UAAU,EAAE,KAAK1D,KAAL,CAAW2D,OAAzC;AAAkDC,MAAAA,YAAY,EAAE,KAAK5B,YAArE;AAAmF6B,MAAAA,YAAY,EAAE,KAAKtD;AAAtG,KAAjC,EAAsJ,UAAUuD,iBAAV,EAA6B;AACvL,UAAIC,KAAK,GAAG7E,KAAK,CAAC8E,QAAN,CAAeC,IAAf,CAAoBhE,KAAK,CAACD,KAAN,CAAYkE,QAAhC,CAAZ;AACA,UAAIC,EAAE,GAAGlE,KAAK,CAACD,KAAN,CAAYmE,EAAZ,IAAkBlE,KAAK,CAACJ,SAAjC;AACA,UAAIU,WAAW,GAAGN,KAAK,CAACgC,KAAN,CAAYL,aAAZ,KAA8BhC,aAAa,CAACsD,MAA5C,IAAsD,CAACjD,KAAK,CAACD,KAAN,CAAYmD,QAAnE,IAA+ElD,KAAK,CAACgC,KAAN,CAAYxB,aAA7G,CAHuL,CAIvL;;AACA,UAAI2D,kBAAkB,GAAGL,KAAK,CAAC/D,KAAN,CAAY6D,YAArC;AACA,UAAIQ,kBAAkB,GAAGN,KAAK,CAAC/D,KAAN,CAAY4D,YAArC;AACA,UAAIU,eAAe,GAAGP,KAAK,CAAC/D,KAAN,CAAYiB,SAAlC;AACA,UAAIsD,YAAJ;AACA,UAAIC,aAAJ;;AACA,UAAIX,YAAY,GAAG,UAAUrD,KAAV,EAAiB;AAChC,YAAIsD,iBAAiB,CAACD,YAAtB,EAAoC;AAChCC,UAAAA,iBAAiB,CAACD,YAAlB,CAA+BrD,KAA/B;AACH;;AACD,YAAI4D,kBAAJ,EAAwB;AACpBA,UAAAA,kBAAkB,CAAC5D,KAAD,CAAlB;AACH;AACJ,OAPD;;AAQA,UAAIoD,YAAY,GAAG,UAAUpD,KAAV,EAAiB;AAChC,YAAIsD,iBAAiB,CAACF,YAAtB,EAAoC;AAChCE,UAAAA,iBAAiB,CAACF,YAAlB,CAA+BpD,KAA/B;AACH;;AACD,YAAI6D,kBAAJ,EAAwB;AACpBA,UAAAA,kBAAkB,CAAC7D,KAAD,CAAlB;AACH;AACJ,OAPD;;AAQA,UAAIS,SAAS,GAAG,UAAUT,KAAV,EAAiB;AAC7B,YAAIA,KAAK,CAAC6B,KAAN,KAAgB5C,OAAO,CAAC6C,MAAxB,IAAkC/B,WAAtC,EAAmD;AAC/CN,UAAAA,KAAK,CAACiB,QAAN,CAAe;AAAEU,YAAAA,aAAa,EAAEhC,aAAa,CAACsD;AAA/B,WAAf;;AACA1C,UAAAA,KAAK,CAACiE,cAAN;AACH;;AACD,YAAIH,eAAJ,EAAqB;AACjBA,UAAAA,eAAe,CAAC9D,KAAD,CAAf;AACH;AACJ,OARD,CA1BuL,CAmCvL;AACA;AACA;;;AACA,UAAIkE,iBAAiB,GAAGzE,KAAK,CAACD,KAAN,CAAY2E,kBAAZ,IAAkC1E,KAAK,CAACgC,KAAN,CAAYL,aAAZ,KAA8BhC,aAAa,CAACsD,MAA9E,GAAuF1D,SAAS,CAAC2E,EAAD,CAAhG,GAAuGxC,SAA/H;;AACA,UAAIiD,UAAU,GAAG5F,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAK+E,KAAK,CAAC/D,KAAX,CAAT,EAA4B;AAAE6D,QAAAA,YAAY,EAAEA,YAAhB;AAA8BD,QAAAA,YAAY,EAAEA,YAA5C;AAA0D3C,QAAAA,SAAS,EAAEA;AAArE,OAA5B,CAAzB;;AACA,UAAI2D,UAAU,CAAC,kBAAD,CAAV,KAAmCjD,SAAvC,EAAkD;AAC9CiD,QAAAA,UAAU,CAAC,kBAAD,CAAV,GAAiCF,iBAAjC;AACH;;AACD,UAAIG,WAAW,GAAG3F,KAAK,CAAC4F,YAAN,CAAmBf,KAAnB,EAA0Ba,UAA1B,EAAsCb,KAAK,CAAC/D,KAAN,CAAYkE,QAAlD,CAAlB,CA3CuL,CA4CvL;;AACA,UAAIjE,KAAK,CAACD,KAAN,CAAY+E,WAAZ,KAA4B9E,KAAK,CAACD,KAAN,CAAY0B,IAAZ,IAAoBzB,KAAK,CAACD,KAAN,CAAYqD,aAAhC,IAAiDpD,KAAK,CAACD,KAAN,CAAYyB,YAAzF,CAAJ,EAA4G;AACxG8C,QAAAA,YAAY,GAAGR,KAAK,CAAC/D,KAAN,CAAYgF,MAA3B;AACAR,QAAAA,aAAa,GAAGT,KAAK,CAAC/D,KAAN,CAAYiF,OAA5B;;AACA,YAAID,MAAM,GAAG,YAAY;AACrB/E,UAAAA,KAAK,CAACI,KAAN,GAAc,KAAd;;AACA,cAAI,CAACJ,KAAK,CAACK,KAAX,EAAkB;AACdL,YAAAA,KAAK,CAAC+B,YAAN;AACH;;AACD,cAAIuC,YAAJ,EAAkB;AACdA,YAAAA,YAAY;AACf;AACJ,SARD;;AASA,YAAIU,OAAO,GAAG,UAAUzE,KAAV,EAAiB;AAC3B,cAAIC,aAAa,GAAGD,KAAK,CAACE,aAA1B;;AACA,cAAIT,KAAK,CAACU,iBAAN,CAAwBF,aAAxB,CAAJ,EAA4C;AACxCR,YAAAA,KAAK,CAACI,KAAN,GAAc,IAAd;AACAd,YAAAA,eAAe,MACXU,KAAK,CAACiB,QAAN,CAAe;AACXT,cAAAA,aAAa,EAAED,KAAK,CAAC0E,MADV;AAEX/D,cAAAA,YAAY,EAAE;AAAEC,gBAAAA,UAAU,EAAE,CAAd;AAAiBC,gBAAAA,QAAQ,EAAE;AAA3B,eAFH;AAGXR,cAAAA,YAAY,EAAE;AAAEO,gBAAAA,UAAU,EAAEzB,QAAQ,CAAC2B,MAAvB;AAA+BD,gBAAAA,QAAQ,EAAE1B,QAAQ,CAAC4B;AAAlD,eAHH;AAIXX,cAAAA,WAAW,EAAEe,SAJF;AAKXH,cAAAA,SAAS,EAAEvB,KAAK,CAACD,KAAN,CAAYyB,YAAZ,IAA4B,CAACxB,KAAK,CAACD,KAAN,CAAY0B,IAAzC,GAAgDjB,aAAa,CAACe,SAA9D,GAA0EG,SAL1E;AAMXC,cAAAA,aAAa,EAAEhC,aAAa,CAACiC,OANlB;AAOXC,cAAAA,aAAa,EAAE;AAAEV,gBAAAA,UAAU,EAAEzB,QAAQ,CAAC2B,MAAvB;AAA+BD,gBAAAA,QAAQ,EAAE1B,QAAQ,CAACoC;AAAlD;AAPJ,aAAf,CADJ;AAUH;;AACD,cAAIyC,aAAJ,EAAmB;AACfA,YAAAA,aAAa,CAAChE,KAAD,CAAb;AACH;AACJ,SAlBD;;AAmBAqE,QAAAA,WAAW,GAAI3F,KAAK,CAACsE,aAAN,CAAoBpE,WAApB,EAAiC;AAAE4F,UAAAA,MAAM,EAAEA,MAAV;AAAkBC,UAAAA,OAAO,EAAEA,OAA3B;AAAoCE,UAAAA,wBAAwB,EAAE;AAA9D,SAAjC,EAAwGN,WAAxG,CAAf;AACH;;AACD,aAAQ3F,KAAK,CAACsE,aAAN,CAAoBtE,KAAK,CAACkG,QAA1B,EAAoC,IAApC,EACJP,WADI,EAEJtE,WAAW,GAAIrB,KAAK,CAACsE,aAAN,CAAoBrE,OAApB,EAA6B;AAAEsB,QAAAA,aAAa,EAAER,KAAK,CAACgC,KAAN,CAAYxB,aAA7B;AAA4CU,QAAAA,YAAY,EAAElB,KAAK,CAACD,KAAN,CAAYmB,YAAZ,IAA4BlB,KAAK,CAACgC,KAAN,CAAYd,YAAlG;AAAgHN,QAAAA,YAAY,EAAEZ,KAAK,CAACD,KAAN,CAAYa,YAAZ,IAA4BZ,KAAK,CAACgC,KAAN,CAAYpB,YAAtK;AAAoLD,QAAAA,WAAW,EAAEX,KAAK,CAACgC,KAAN,CAAYrB,WAA7M;AAA0NyE,QAAAA,aAAa,EAAEpF,KAAK,CAACD,KAAN,CAAY8B,aAAZ,IAA6B7B,KAAK,CAACgC,KAAN,CAAYH,aAAlR;AAAiSwD,QAAAA,SAAS,EAAEhG,GAAG,CAACW,KAAK,CAACD,KAAN,CAAYsF,SAAb,EAAwB,cAAxB,EAAwCrF,KAAK,CAACgC,KAAN,CAAYL,aAAZ,KAA8BhC,aAAa,CAACqD,SAA5C,IAAyD,uBAAjG,CAA/S;AAA0asC,QAAAA,WAAW,EAAEtF,KAAK,CAACD,KAAN,CAAYuF,WAAnc;AAAgdpB,QAAAA,EAAE,EAAEA,EAApd;AAAwdqB,QAAAA,GAAG,EAAErB,EAA7d;AAAienB,QAAAA,cAAc,EAAE/C,KAAK,CAAC+C,cAAvf;AAAugBa,QAAAA,YAAY,EAAEC,iBAAiB,CAACD,YAAviB;AAAqjBD,QAAAA,YAAY,EAAEE,iBAAiB,CAACF,YAArlB;AAAmmB6B,QAAAA,WAAW,EAAE;AAAEH,UAAAA,SAAS,EAAE;AAAb,SAAhnB;AAAspBnF,QAAAA,UAAU,EAAEF,KAAK,CAACE,UAAxqB;AAAorBuF,QAAAA,IAAI,EAAE;AAA1rB,OAA7B,EACXxG,KAAK,CAACsE,aAAN,CAAoB,KAApB,EAA2B;AAAE8B,QAAAA,SAAS,EAAE;AAAb,OAA3B,EAA0ErF,KAAK,CAACD,KAAN,CAAYqD,aAAZ,IAA6BpD,KAAK,CAACD,KAAN,CAAYqD,aAAZ,EAA9B,IAA8DpD,KAAK,CAACD,KAAN,CAAY0B,IAA1E,IAAkFzB,KAAK,CAACgC,KAAN,CAAYT,SAAvK,CADW,CAAJ,GAC+K,IAHtL,CAAR;AAIH,KAlFO,CAAR;AAmFH,GArFD;;AAsFA1B,EAAAA,OAAO,CAACwD,SAAR,CAAkBqC,oBAAlB,GAAyC,YAAY;AACjD5E,IAAAA,QAAQ,CAACmB,mBAAT,CAA6B,SAA7B,EAAwC,KAAKjB,SAA7C;AACH,GAFD;;AAGAnB,EAAAA,OAAO,CAAC8F,YAAR,GAAuB;AACnBjC,IAAAA,OAAO,EAAE,GADU;AAEnBoB,IAAAA,WAAW,EAAE;AAFM,GAAvB;AAIA,SAAOjF,OAAP;AACH,CAjL4B,CAiL3BZ,KAAK,CAAC2G,SAjLqB,CAA7B;;AAkLA,SAAS/F,OAAT;;AACA,SAASsD,gBAAT,CAA0B3C,aAA1B,EAAyC;AACrC,SAAOA,aAAa,CAACqF,WAAd,GAA4BC,IAAI,CAACC,IAAL,CAAUvF,aAAa,CAACwF,WAAxB,CAAnC;AACH","sourcesContent":["import { __assign, __extends } from \"tslib\";\r\nimport \"../../CommonImports\";\r\nimport \"../../Core/core.css\";\r\nimport \"./Tooltip.css\";\r\nimport * as React from \"react\";\r\nimport { Callout } from '../../Callout';\r\nimport { FocusWithin } from '../../FocusWithin';\r\nimport { MouseWithin } from '../../MouseWithin';\r\nimport { css, getFocusVisible, getSafeId, KeyCode, Mouse } from '../../Util';\r\nimport { Location } from '../../Utilities/Position';\r\nexport var TooltipStatus;\r\n(function (TooltipStatus) {\r\n    TooltipStatus[TooltipStatus[\"hidden\"] = 0] = \"hidden\";\r\n    TooltipStatus[TooltipStatus[\"visible\"] = 1] = \"visible\";\r\n    TooltipStatus[TooltipStatus[\"fadingout\"] = 2] = \"fadingout\";\r\n})(TooltipStatus || (TooltipStatus = {}));\r\nvar tooltipId = 1;\r\nvar Tooltip = /** @class */ (function (_super) {\r\n    __extends(Tooltip, _super);\r\n    function Tooltip(props) {\r\n        var _this = _super.call(this, props) || this;\r\n        _this.contentRef = React.createRef();\r\n        _this.tooltipId = \"tooltip-\" + tooltipId++;\r\n        _this.focus = false;\r\n        _this.mouse = false;\r\n        _this.showTooltip = function (event) {\r\n            var anchorElement = event.currentTarget;\r\n            if (_this.shouldShowTooltip(anchorElement)) {\r\n                // If no anchorOrigin was specified use the Mouse.position when we show the toolip.\r\n                var anchorPoint = void 0;\r\n                if (!_this.props.anchorOrigin) {\r\n                    anchorPoint = Mouse.position;\r\n                }\r\n                _this.mouse = true;\r\n                document.addEventListener(\"keydown\", _this.onKeyDown);\r\n                _this.setState({\r\n                    anchorElement: anchorElement,\r\n                    anchorOffset: { horizontal: 8, vertical: 8 },\r\n                    anchorOrigin: { horizontal: Location.center, vertical: Location.end },\r\n                    anchorPoint: anchorPoint,\r\n                    innerText: _this.props.overflowOnly && !_this.props.text ? anchorElement.innerText : undefined,\r\n                    tooltipStatus: TooltipStatus.visible,\r\n                    tooltipOrigin: { horizontal: Location.start, vertical: Location.start }\r\n                });\r\n            }\r\n        };\r\n        _this.closeTooltip = function () {\r\n            if (!(_this.focus && getFocusVisible()) && _this.state.tooltipStatus === TooltipStatus.visible) {\r\n                _this.mouse = false;\r\n                document.removeEventListener(\"keydown\", _this.onKeyDown);\r\n                _this.setState({ tooltipStatus: _this.getDismissStatus() });\r\n            }\r\n        };\r\n        _this.onKeyDown = function (event) {\r\n            var _a;\r\n            if (event.which === KeyCode.escape && _this.state.tooltipStatus === TooltipStatus.visible) {\r\n                _this.closeTooltip();\r\n            }\r\n            if (event.which === KeyCode.ctrl && _this.state.tooltipStatus === TooltipStatus.visible) {\r\n                var container = _this.contentRef.current;\r\n                var selectionNode = (_a = window.getSelection()) === null || _a === void 0 ? void 0 : _a.anchorNode;\r\n                var hasSelectionInTooltip = container && selectionNode && container.contains(selectionNode);\r\n                // Ctrl keystroke anywhere will dismiss the callout as per MAS 1.4.13,\r\n                // except if user has selected something inside, in which case we allow Ctrl-C.\r\n                if (!hasSelectionInTooltip) {\r\n                    _this.closeTooltip();\r\n                }\r\n            }\r\n        };\r\n        _this.onAnimationEnd = function () {\r\n            if (_this.state.tooltipStatus === TooltipStatus.fadingout) {\r\n                _this.setState({\r\n                    tooltipStatus: TooltipStatus.hidden\r\n                });\r\n            }\r\n        };\r\n        _this.getDismissStatus = function () {\r\n            return _this.props.disabled ? TooltipStatus.hidden : TooltipStatus.fadingout;\r\n        };\r\n        _this.shouldShowTooltip = function (anchorElement) {\r\n            if (_this.state.tooltipStatus !== TooltipStatus.hidden) {\r\n                return false;\r\n            }\r\n            // If the tooltip only appears when the anchorElement overflows its parent then\r\n            // we need to check on mouse enter.\r\n            if (_this.props.overflowOnly && !_this.overflowDetected(anchorElement)) {\r\n                return false;\r\n            }\r\n            // Dont show the tooltip if there is not content to show.\r\n            if (!(_this.props.text || _this.props.renderContent || (anchorElement.innerText && _this.props.overflowOnly))) {\r\n                return false;\r\n            }\r\n            return !_this.props.disabled;\r\n        };\r\n        _this.overflowDetected = props.overflowDetected || overflowDetected;\r\n        _this.state = {\r\n            tooltipStatus: TooltipStatus.hidden\r\n        };\r\n        return _this;\r\n    }\r\n    Tooltip.prototype.render = function () {\r\n        var _this = this;\r\n        return (React.createElement(MouseWithin, { leaveDelay: 50, enterDelay: this.props.delayMs, onMouseLeave: this.closeTooltip, onMouseEnter: this.showTooltip }, function (mouseWithinEvents) {\r\n            var child = React.Children.only(_this.props.children);\r\n            var id = _this.props.id || _this.tooltipId;\r\n            var showTooltip = _this.state.tooltipStatus !== TooltipStatus.hidden && !_this.props.disabled && _this.state.anchorElement;\r\n            // Save the existing events we will potentially proxy.\r\n            var existingMouseEnter = child.props.onMouseEnter;\r\n            var existingMouseLeave = child.props.onMouseLeave;\r\n            var existingKeyDown = child.props.onKeyDown;\r\n            var existingBlur;\r\n            var existingFocus;\r\n            var onMouseEnter = function (event) {\r\n                if (mouseWithinEvents.onMouseEnter) {\r\n                    mouseWithinEvents.onMouseEnter(event);\r\n                }\r\n                if (existingMouseEnter) {\r\n                    existingMouseEnter(event);\r\n                }\r\n            };\r\n            var onMouseLeave = function (event) {\r\n                if (mouseWithinEvents.onMouseLeave) {\r\n                    mouseWithinEvents.onMouseLeave(event);\r\n                }\r\n                if (existingMouseLeave) {\r\n                    existingMouseLeave(event);\r\n                }\r\n            };\r\n            var onKeyDown = function (event) {\r\n                if (event.which === KeyCode.escape && showTooltip) {\r\n                    _this.setState({ tooltipStatus: TooltipStatus.hidden });\r\n                    event.preventDefault();\r\n                }\r\n                if (existingKeyDown) {\r\n                    existingKeyDown(event);\r\n                }\r\n            };\r\n            // to not let consumers have to care about an implementation detail, wrap\r\n            // the tooltip id in getSafeId and use that as the aria-describedBy property\r\n            // on the child.\r\n            var ariaDescribedById = _this.props.addAriaDescribedBy && _this.state.tooltipStatus !== TooltipStatus.hidden ? getSafeId(id) : undefined;\r\n            var childProps = __assign(__assign({}, child.props), { onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, onKeyDown: onKeyDown });\r\n            if (childProps[\"aria-describedby\"] === undefined) {\r\n                childProps[\"aria-describedby\"] = ariaDescribedById;\r\n            }\r\n            var clonedChild = React.cloneElement(child, childProps, child.props.children);\r\n            // If this tooltip should become visible when focus is within the component add the focus tracking.\r\n            if (_this.props.showOnFocus && (_this.props.text || _this.props.renderContent || _this.props.overflowOnly)) {\r\n                existingBlur = child.props.onBlur;\r\n                existingFocus = child.props.onFocus;\r\n                var onBlur = function () {\r\n                    _this.focus = false;\r\n                    if (!_this.mouse) {\r\n                        _this.closeTooltip();\r\n                    }\r\n                    if (existingBlur) {\r\n                        existingBlur();\r\n                    }\r\n                };\r\n                var onFocus = function (event) {\r\n                    var anchorElement = event.currentTarget;\r\n                    if (_this.shouldShowTooltip(anchorElement)) {\r\n                        _this.focus = true;\r\n                        getFocusVisible() &&\r\n                            _this.setState({\r\n                                anchorElement: event.target,\r\n                                anchorOffset: { horizontal: 0, vertical: 8 },\r\n                                anchorOrigin: { horizontal: Location.center, vertical: Location.end },\r\n                                anchorPoint: undefined,\r\n                                innerText: _this.props.overflowOnly && !_this.props.text ? anchorElement.innerText : undefined,\r\n                                tooltipStatus: TooltipStatus.visible,\r\n                                tooltipOrigin: { horizontal: Location.center, vertical: Location.start }\r\n                            });\r\n                    }\r\n                    if (existingFocus) {\r\n                        existingFocus(event);\r\n                    }\r\n                };\r\n                clonedChild = (React.createElement(FocusWithin, { onBlur: onBlur, onFocus: onFocus, updateStateOnFocusChange: false }, clonedChild));\r\n            }\r\n            return (React.createElement(React.Fragment, null,\r\n                clonedChild,\r\n                showTooltip ? (React.createElement(Callout, { anchorElement: _this.state.anchorElement, anchorOffset: _this.props.anchorOffset || _this.state.anchorOffset, anchorOrigin: _this.props.anchorOrigin || _this.state.anchorOrigin, anchorPoint: _this.state.anchorPoint, calloutOrigin: _this.props.tooltipOrigin || _this.state.tooltipOrigin, className: css(_this.props.className, \"bolt-tooltip\", _this.state.tooltipStatus === TooltipStatus.fadingout && \"bolt-tooltip-fade-out\"), fixedLayout: _this.props.fixedLayout, id: id, key: id, onAnimationEnd: _this.onAnimationEnd, onMouseEnter: mouseWithinEvents.onMouseEnter, onMouseLeave: mouseWithinEvents.onMouseLeave, portalProps: { className: \"bolt-tooltip-portal\" }, contentRef: _this.contentRef, role: \"tooltip\" },\r\n                    React.createElement(\"div\", { className: \"bolt-tooltip-content body-m\" }, (_this.props.renderContent && _this.props.renderContent()) || _this.props.text || _this.state.innerText))) : null));\r\n        }));\r\n    };\r\n    Tooltip.prototype.componentWillUnmount = function () {\r\n        document.removeEventListener(\"keydown\", this.onKeyDown);\r\n    };\r\n    Tooltip.defaultProps = {\r\n        delayMs: 250,\r\n        showOnFocus: true\r\n    };\r\n    return Tooltip;\r\n}(React.Component));\r\nexport { Tooltip };\r\nfunction overflowDetected(anchorElement) {\r\n    return anchorElement.scrollWidth > Math.ceil(anchorElement.offsetWidth);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}