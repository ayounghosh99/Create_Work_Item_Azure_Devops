{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport \"../../CommonImports\";\nimport \"../../Core/core.css\";\nimport * as React from \"react\";\nimport { FocusGroup } from '../../FocusGroup';\nimport { ElementRelationship, getRelationship, KeyCode, shimRef } from '../../Util';\nimport { FocusZoneDirection, FocusZoneKeyStroke } from \"./FocusZone.Props\"; // The FocusZoneContext carries the identifier for the current FocusZone.\n\nexport var FocusZoneContext = React.createContext({\n  direction: undefined,\n  focuszoneId: undefined\n}); // As an event propagates through the hierarchy of focus zones it may\n// be marked as ignored. This allows a child focus zone to mark an event\n// as \"pass-through\" for all of its parents.\n\nvar ignoreEvent = false; // An internal identifier used to created unique focuszoneId's.\n\nvar focuszoneId = 1;\n\nvar FocusZone =\n/** @class */\nfunction (_super) {\n  __extends(FocusZone, _super);\n\n  function FocusZone(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.rootElements = [];\n    _this.state = {\n      focuszoneId: \"focuszone-\" + focuszoneId++\n    };\n    return _this;\n  }\n\n  FocusZone.prototype.render = function () {\n    var _this = this; // We need to shim the KeyDown event on each of the children. This allows us to capture\n    // the event and process it for focus changes.\n\n\n    var content = React.createElement(FocusZoneContext.Consumer, null, function (parentContext) {\n      return React.createElement(FocusZoneContext.Provider, {\n        value: {\n          direction: _this.props.direction,\n          focuszoneId: _this.state.focuszoneId\n        }\n      }, React.Children.map(_this.props.children, function (child, index) {\n        if (child === null || typeof child === \"string\" || typeof child === \"number\") {\n          return child;\n        } // All direct children MUST be DOM elements.\n\n\n        if (typeof child.type !== \"string\") {\n          throw Error(\"Children of a focus zone MUST be DOM elements\");\n        } // Save the supplied keydown event handler so we can forward the event to it.\n\n\n        var existingOnKeyDown = child.props.onKeyDown;\n        var existingOnFocus = child.props.onFocus; // Save the component reference for this element, either the one from the original\n        // component or the one we added.\n\n        _this.rootElements[index] = shimRef(child);\n        return React.cloneElement(child, __assign(__assign({\n          key: index\n        }, child.props), {\n          ref: _this.rootElements[index],\n          onFocus: function (event) {\n            var _a;\n\n            if (existingOnFocus) {\n              existingOnFocus(event);\n            }\n\n            var focusCurrent = document.activeElement;\n\n            for (var index_1 = 0; index_1 < _this.rootElements.length; index_1++) {\n              var rootElement = (_a = _this.rootElements[index_1]) === null || _a === void 0 ? void 0 : _a.current;\n\n              if (rootElement && (rootElement.contains(focusCurrent) || rootElement === focusCurrent)) {\n                _this.lastFocusElement = event.target;\n              }\n            }\n          },\n          onKeyDown: function (event) {\n            var ignoreKeystroke = FocusZoneKeyStroke.IgnoreNone;\n\n            if (existingOnKeyDown) {\n              existingOnKeyDown(event);\n            } // Determine whether or not this focuszone wants to preprocess this keystroke\n            // and mark the current propagation as ignored.\n\n\n            if (!ignoreEvent && _this.props.preprocessKeyStroke) {\n              ignoreKeystroke = _this.props.preprocessKeyStroke(event);\n\n              if (ignoreKeystroke === FocusZoneKeyStroke.IgnoreAll) {\n                ignoreEvent = true;\n              }\n            }\n\n            if (!ignoreEvent) {\n              if (!event.defaultPrevented && !_this.props.disabled) {\n                var nodeName = event.target.nodeName;\n                var offset = void 0; // Logic to handle input / text area tags\n\n                var inputPosition = void 0;\n                var inputLength = void 0;\n\n                if (nodeName === \"INPUT\" || nodeName === \"TEXTAREA\") {\n                  var input = event.target;\n\n                  try {\n                    inputPosition = typeof input.selectionStart === \"number\" ? input.selectionStart : undefined;\n                  } catch (_a) {// Microsoft Edge throws InvalidStateError when calling 'input.selectionStart' on non-supported input element types\n                    // according to https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement\n                    // Ignore this error\n                  }\n\n                  inputLength = input.value.length;\n                }\n\n                var allowLeftArrow = inputPosition === undefined || inputPosition === 0 && _this.props.allowArrowOutOfInputs;\n                var allowRightArrow = inputPosition === undefined || inputLength === undefined || inputPosition === inputLength && _this.props.allowArrowOutOfInputs;\n\n                switch (event.which) {\n                  case KeyCode.upArrow:\n                    if (nodeName !== \"TEXTAREA\") {\n                      if (_this.props.direction === FocusZoneDirection.Vertical) {\n                        offset = -1;\n                      }\n                    }\n\n                    break;\n\n                  case KeyCode.downArrow:\n                    if (nodeName !== \"TEXTAREA\") {\n                      if (_this.props.direction === FocusZoneDirection.Vertical) {\n                        offset = 1;\n                      }\n                    }\n\n                    break;\n\n                  case KeyCode.rightArrow:\n                    if (allowRightArrow) {\n                      if (_this.props.direction === FocusZoneDirection.Horizontal) {\n                        offset = 1;\n                      }\n                    }\n\n                    break;\n\n                  case KeyCode.leftArrow:\n                    if (allowLeftArrow) {\n                      if (_this.props.direction === FocusZoneDirection.Horizontal) {\n                        offset = -1;\n                      }\n                    }\n\n                    break;\n\n                  case KeyCode.tab:\n                    if (_this.props.handleTabKey) {\n                      offset = event.shiftKey ? -1 : 1;\n                    }\n\n                    break;\n\n                  case KeyCode.enter:\n                    if (_this.props.activateOnEnter) {\n                      event.target.click();\n                    }\n\n                }\n\n                if (offset) {\n                  if (_this.focusNextElement(event, offset)) {\n                    event.preventDefault();\n                  }\n                }\n              }\n            }\n\n            if (ignoreKeystroke === FocusZoneKeyStroke.IgnoreParents) {\n              ignoreEvent = true;\n            } // Perform any supplied event post processing.\n\n\n            if (!ignoreEvent && _this.props.postprocessKeyStroke) {\n              if (_this.props.postprocessKeyStroke(event) === FocusZoneKeyStroke.IgnoreParents) {\n                ignoreEvent = true;\n              }\n            } // Once we reach the root focuszone we need to clear the ignoredEvent.\n\n\n            if (!parentContext.focuszoneId) {\n              ignoreEvent = false;\n            }\n          }\n        }));\n      }));\n    });\n\n    if (this.props.focusGroupProps) {\n      content = React.createElement(FocusGroup, __assign({}, this.props.focusGroupProps), content);\n    }\n\n    return content;\n  };\n\n  FocusZone.prototype.componentDidMount = function () {\n    var focusElement; // If a defaultActiveElement is supplied we will focus it. It is not required to\n    // be member of the focus zone, it can be any element.\n\n    if (this.props.focusOnMount) {\n      var defaultActiveElement = this.props.defaultActiveElement;\n      var focusElements = this.getFocusElements(typeof defaultActiveElement === \"function\" ? defaultActiveElement() : defaultActiveElement);\n\n      if (focusElements.length > 0) {\n        focusElement = focusElements[0];\n      }\n    }\n\n    if (focusElement) {\n      focusElement.focus();\n    }\n  };\n\n  FocusZone.prototype.focusNextElement = function (event, offset) {\n    var focusElements = this.getFocusElements();\n\n    if (focusElements.length > 0) {\n      var focusCurrent = document.activeElement;\n      var rootElements = this.rootElements; // Determine if an element in the focus zone has focus.\n\n      var focusIndex = focusElements.indexOf(focusCurrent); // Focus may not be on an element in the zone so we need to\n      // figure out which one we are between in this case.\n\n      if (focusIndex === -1) {\n        var index = 0; // Determine if the element is in a portal or directly within a focuszone root.\n\n        for (index = 0; index < rootElements.length; index++) {\n          var elementRef = rootElements[index];\n\n          if (elementRef.current) {\n            if (elementRef.current.contains(event.target)) {\n              break;\n            }\n          }\n        } // If this is coming from a portal, we will use the element that last had focus.\n\n\n        if (index === this.rootElements.length && this.lastFocusElement) {\n          focusIndex = focusElements.indexOf(this.lastFocusElement);\n        } else {\n          for (index = 0; index < focusElements.length; index++) {\n            var relationship = getRelationship(focusCurrent, focusElements[index]);\n\n            if (relationship === ElementRelationship.Before) {\n              focusIndex = index - (offset > 0 ? 1 : 0);\n              break;\n            } else if (relationship === ElementRelationship.Child) {\n              focusIndex = index;\n              break;\n            } else if (relationship === ElementRelationship.After && index === focusElements.length - 1) {\n              focusIndex = focusElements.length;\n            }\n          }\n        }\n      } // Move to the next component in the set of focus zone components.\n\n\n      focusIndex += offset; // If the FocusZone supports circular navigation and we are on the end\n      // we will move to the element on the opposite end.\n\n      if (this.props.circularNavigation) {\n        if (focusIndex < 0) {\n          focusIndex = focusElements.length - 1;\n        } else if (focusIndex >= focusElements.length) {\n          focusIndex = 0;\n        }\n      } // If we ended up on a focusable element update the focus.\n\n\n      if (focusIndex > -1 && focusIndex < focusElements.length) {\n        focusElements[focusIndex].focus();\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  FocusZone.prototype.getFocusElements = function (customSelector) {\n    var focusElements = [];\n    var selector = customSelector; // If a custom selector was supplied we will use it.\n\n    if (!selector) {\n      // The default selector will just pick up items tagged with this focuszone id.\n      selector = \"[data-focuszone~=\" + this.state.focuszoneId + \"]\"; // If we are including the default elements from the DOM we will add the\n      // default selector to our list of selectors.\n\n      if (this.props.includeDefaults) {\n        selector += \",a[href],button,iframe,input,select,textarea,[tabIndex]\";\n      }\n    } // Filter the elements that matched our query to the elements that are elligible\n    // for receiving focus in this focuszone.\n\n\n    for (var _i = 0, _a = this.rootElements; _i < _a.length; _i++) {\n      var rootElement = _a[_i];\n\n      if (rootElement.current) {\n        var focusChildren = rootElement.current.querySelectorAll(selector); // Check if the root element matches our selector.\n\n        if (rootElement.current.matches(selector) && this.isFocusElement(rootElement.current, customSelector)) {\n          focusElements.push(rootElement.current);\n        } // Check all the children of the root that are potential focus elements.\n\n\n        for (var rootIndex = 0; rootIndex < focusChildren.length; rootIndex++) {\n          var element = focusChildren[rootIndex];\n\n          if (this.isFocusElement(element, customSelector)) {\n            focusElements.push(element);\n          }\n        }\n      }\n    }\n\n    return focusElements;\n  };\n  /**\r\n   * isFocusElement is used to determine whether or not an element should participate\r\n   * in this focus zone.\r\n   *\r\n   * @param element HTML Element that you are testing as a valid focus element.\r\n   *\r\n   * @param customSelector A custom selector that is used to match elements with\r\n   *  negative tabIndex. These wont match normally unless targetted by the custom\r\n   *  selector.\r\n   */\n\n\n  FocusZone.prototype.isFocusElement = function (element, customSelector) {\n    // Filter out elements that are disabled.\n    if (element.hasAttribute(\"disabled\")) {\n      return false;\n    }\n\n    if (!customSelector) {\n      // Filter out elements that are not visible.\n      if (!this.props.skipHiddenCheck) {\n        var style = window.getComputedStyle(element);\n\n        if (style.visibility === \"hidden\" || style.display === \"none\" || !(element.offsetWidth || element.offsetHeight || element.getClientRects().length)) {\n          return false;\n        }\n      } // Filter out elements with negative tabIndex that aren't\n      // explicity marked for this focuszone.\n\n\n      var tabIndex = element.getAttribute(\"tabindex\");\n\n      if (tabIndex && parseInt(tabIndex) < 0) {\n        var focuszoneId_1 = element.getAttribute(\"data-focuszone\");\n\n        if (!focuszoneId_1 || focuszoneId_1.indexOf(this.state.focuszoneId) < 0) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  return FocusZone;\n}(React.Component);\n\nexport { FocusZone };","map":{"version":3,"sources":["/Users/ayounghosh/Downloads/Create_Work_Item_Azure_Devops/Front_End/node_modules/azure-devops-ui/Components/FocusZone/FocusZone.js"],"names":["__assign","__extends","React","FocusGroup","ElementRelationship","getRelationship","KeyCode","shimRef","FocusZoneDirection","FocusZoneKeyStroke","FocusZoneContext","createContext","direction","undefined","focuszoneId","ignoreEvent","FocusZone","_super","props","_this","call","rootElements","state","prototype","render","content","createElement","Consumer","parentContext","Provider","value","Children","map","children","child","index","type","Error","existingOnKeyDown","onKeyDown","existingOnFocus","onFocus","cloneElement","key","ref","event","_a","focusCurrent","document","activeElement","index_1","length","rootElement","current","contains","lastFocusElement","target","ignoreKeystroke","IgnoreNone","preprocessKeyStroke","IgnoreAll","defaultPrevented","disabled","nodeName","offset","inputPosition","inputLength","input","selectionStart","allowLeftArrow","allowArrowOutOfInputs","allowRightArrow","which","upArrow","Vertical","downArrow","rightArrow","Horizontal","leftArrow","tab","handleTabKey","shiftKey","enter","activateOnEnter","click","focusNextElement","preventDefault","IgnoreParents","postprocessKeyStroke","focusGroupProps","componentDidMount","focusElement","focusOnMount","defaultActiveElement","focusElements","getFocusElements","focus","focusIndex","indexOf","elementRef","relationship","Before","Child","After","circularNavigation","customSelector","selector","includeDefaults","_i","focusChildren","querySelectorAll","matches","isFocusElement","push","rootIndex","element","hasAttribute","skipHiddenCheck","style","window","getComputedStyle","visibility","display","offsetWidth","offsetHeight","getClientRects","tabIndex","getAttribute","parseInt","focuszoneId_1","Component"],"mappings":"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","sourcesContent":["import { __assign, __extends } from \"tslib\";\r\nimport \"../../CommonImports\";\r\nimport \"../../Core/core.css\";\r\nimport * as React from \"react\";\r\nimport { FocusGroup } from '../../FocusGroup';\r\nimport { ElementRelationship, getRelationship, KeyCode, shimRef } from '../../Util';\r\nimport { FocusZoneDirection, FocusZoneKeyStroke } from \"./FocusZone.Props\";\r\n// The FocusZoneContext carries the identifier for the current FocusZone.\r\nexport var FocusZoneContext = React.createContext({ direction: undefined, focuszoneId: undefined });\r\n// As an event propagates through the hierarchy of focus zones it may\r\n// be marked as ignored. This allows a child focus zone to mark an event\r\n// as \"pass-through\" for all of its parents.\r\nvar ignoreEvent = false;\r\n// An internal identifier used to created unique focuszoneId's.\r\nvar focuszoneId = 1;\r\nvar FocusZone = /** @class */ (function (_super) {\r\n    __extends(FocusZone, _super);\r\n    function FocusZone(props) {\r\n        var _this = _super.call(this, props) || this;\r\n        _this.rootElements = [];\r\n        _this.state = {\r\n            focuszoneId: \"focuszone-\" + focuszoneId++\r\n        };\r\n        return _this;\r\n    }\r\n    FocusZone.prototype.render = function () {\r\n        var _this = this;\r\n        // We need to shim the KeyDown event on each of the children. This allows us to capture\r\n        // the event and process it for focus changes.\r\n        var content = (React.createElement(FocusZoneContext.Consumer, null, function (parentContext) { return (React.createElement(FocusZoneContext.Provider, { value: { direction: _this.props.direction, focuszoneId: _this.state.focuszoneId } }, React.Children.map(_this.props.children, function (child, index) {\r\n            if (child === null || typeof child === \"string\" || typeof child === \"number\") {\r\n                return child;\r\n            }\r\n            // All direct children MUST be DOM elements.\r\n            if (typeof child.type !== \"string\") {\r\n                throw Error(\"Children of a focus zone MUST be DOM elements\");\r\n            }\r\n            // Save the supplied keydown event handler so we can forward the event to it.\r\n            var existingOnKeyDown = child.props.onKeyDown;\r\n            var existingOnFocus = child.props.onFocus;\r\n            // Save the component reference for this element, either the one from the original\r\n            // component or the one we added.\r\n            _this.rootElements[index] = shimRef(child);\r\n            return React.cloneElement(child, __assign(__assign({ key: index }, child.props), { ref: _this.rootElements[index], onFocus: function (event) {\r\n                    var _a;\r\n                    if (existingOnFocus) {\r\n                        existingOnFocus(event);\r\n                    }\r\n                    var focusCurrent = document.activeElement;\r\n                    for (var index_1 = 0; index_1 < _this.rootElements.length; index_1++) {\r\n                        var rootElement = (_a = _this.rootElements[index_1]) === null || _a === void 0 ? void 0 : _a.current;\r\n                        if (rootElement && (rootElement.contains(focusCurrent) || rootElement === focusCurrent)) {\r\n                            _this.lastFocusElement = event.target;\r\n                        }\r\n                    }\r\n                }, onKeyDown: function (event) {\r\n                    var ignoreKeystroke = FocusZoneKeyStroke.IgnoreNone;\r\n                    if (existingOnKeyDown) {\r\n                        existingOnKeyDown(event);\r\n                    }\r\n                    // Determine whether or not this focuszone wants to preprocess this keystroke\r\n                    // and mark the current propagation as ignored.\r\n                    if (!ignoreEvent && _this.props.preprocessKeyStroke) {\r\n                        ignoreKeystroke = _this.props.preprocessKeyStroke(event);\r\n                        if (ignoreKeystroke === FocusZoneKeyStroke.IgnoreAll) {\r\n                            ignoreEvent = true;\r\n                        }\r\n                    }\r\n                    if (!ignoreEvent) {\r\n                        if (!event.defaultPrevented && !_this.props.disabled) {\r\n                            var nodeName = event.target.nodeName;\r\n                            var offset = void 0;\r\n                            // Logic to handle input / text area tags\r\n                            var inputPosition = void 0;\r\n                            var inputLength = void 0;\r\n                            if (nodeName === \"INPUT\" || nodeName === \"TEXTAREA\") {\r\n                                var input = event.target;\r\n                                try {\r\n                                    inputPosition = typeof input.selectionStart === \"number\" ? input.selectionStart : undefined;\r\n                                }\r\n                                catch (_a) {\r\n                                    // Microsoft Edge throws InvalidStateError when calling 'input.selectionStart' on non-supported input element types\r\n                                    // according to https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement\r\n                                    // Ignore this error\r\n                                }\r\n                                inputLength = input.value.length;\r\n                            }\r\n                            var allowLeftArrow = inputPosition === undefined || (inputPosition === 0 && _this.props.allowArrowOutOfInputs);\r\n                            var allowRightArrow = inputPosition === undefined ||\r\n                                inputLength === undefined ||\r\n                                (inputPosition === inputLength && _this.props.allowArrowOutOfInputs);\r\n                            switch (event.which) {\r\n                                case KeyCode.upArrow:\r\n                                    if (nodeName !== \"TEXTAREA\") {\r\n                                        if (_this.props.direction === FocusZoneDirection.Vertical) {\r\n                                            offset = -1;\r\n                                        }\r\n                                    }\r\n                                    break;\r\n                                case KeyCode.downArrow:\r\n                                    if (nodeName !== \"TEXTAREA\") {\r\n                                        if (_this.props.direction === FocusZoneDirection.Vertical) {\r\n                                            offset = 1;\r\n                                        }\r\n                                    }\r\n                                    break;\r\n                                case KeyCode.rightArrow:\r\n                                    if (allowRightArrow) {\r\n                                        if (_this.props.direction === FocusZoneDirection.Horizontal) {\r\n                                            offset = 1;\r\n                                        }\r\n                                    }\r\n                                    break;\r\n                                case KeyCode.leftArrow:\r\n                                    if (allowLeftArrow) {\r\n                                        if (_this.props.direction === FocusZoneDirection.Horizontal) {\r\n                                            offset = -1;\r\n                                        }\r\n                                    }\r\n                                    break;\r\n                                case KeyCode.tab:\r\n                                    if (_this.props.handleTabKey) {\r\n                                        offset = event.shiftKey ? -1 : 1;\r\n                                    }\r\n                                    break;\r\n                                case KeyCode.enter:\r\n                                    if (_this.props.activateOnEnter) {\r\n                                        event.target.click();\r\n                                    }\r\n                            }\r\n                            if (offset) {\r\n                                if (_this.focusNextElement(event, offset)) {\r\n                                    event.preventDefault();\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    if (ignoreKeystroke === FocusZoneKeyStroke.IgnoreParents) {\r\n                        ignoreEvent = true;\r\n                    }\r\n                    // Perform any supplied event post processing.\r\n                    if (!ignoreEvent && _this.props.postprocessKeyStroke) {\r\n                        if (_this.props.postprocessKeyStroke(event) === FocusZoneKeyStroke.IgnoreParents) {\r\n                            ignoreEvent = true;\r\n                        }\r\n                    }\r\n                    // Once we reach the root focuszone we need to clear the ignoredEvent.\r\n                    if (!parentContext.focuszoneId) {\r\n                        ignoreEvent = false;\r\n                    }\r\n                } }));\r\n        }))); }));\r\n        if (this.props.focusGroupProps) {\r\n            content = React.createElement(FocusGroup, __assign({}, this.props.focusGroupProps), content);\r\n        }\r\n        return content;\r\n    };\r\n    FocusZone.prototype.componentDidMount = function () {\r\n        var focusElement;\r\n        // If a defaultActiveElement is supplied we will focus it. It is not required to\r\n        // be member of the focus zone, it can be any element.\r\n        if (this.props.focusOnMount) {\r\n            var defaultActiveElement = this.props.defaultActiveElement;\r\n            var focusElements = this.getFocusElements(typeof defaultActiveElement === \"function\" ? defaultActiveElement() : defaultActiveElement);\r\n            if (focusElements.length > 0) {\r\n                focusElement = focusElements[0];\r\n            }\r\n        }\r\n        if (focusElement) {\r\n            focusElement.focus();\r\n        }\r\n    };\r\n    FocusZone.prototype.focusNextElement = function (event, offset) {\r\n        var focusElements = this.getFocusElements();\r\n        if (focusElements.length > 0) {\r\n            var focusCurrent = document.activeElement;\r\n            var rootElements = this.rootElements;\r\n            // Determine if an element in the focus zone has focus.\r\n            var focusIndex = focusElements.indexOf(focusCurrent);\r\n            // Focus may not be on an element in the zone so we need to\r\n            // figure out which one we are between in this case.\r\n            if (focusIndex === -1) {\r\n                var index = 0;\r\n                // Determine if the element is in a portal or directly within a focuszone root.\r\n                for (index = 0; index < rootElements.length; index++) {\r\n                    var elementRef = rootElements[index];\r\n                    if (elementRef.current) {\r\n                        if (elementRef.current.contains(event.target)) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                // If this is coming from a portal, we will use the element that last had focus.\r\n                if (index === this.rootElements.length && this.lastFocusElement) {\r\n                    focusIndex = focusElements.indexOf(this.lastFocusElement);\r\n                }\r\n                else {\r\n                    for (index = 0; index < focusElements.length; index++) {\r\n                        var relationship = getRelationship(focusCurrent, focusElements[index]);\r\n                        if (relationship === ElementRelationship.Before) {\r\n                            focusIndex = index - (offset > 0 ? 1 : 0);\r\n                            break;\r\n                        }\r\n                        else if (relationship === ElementRelationship.Child) {\r\n                            focusIndex = index;\r\n                            break;\r\n                        }\r\n                        else if (relationship === ElementRelationship.After && index === focusElements.length - 1) {\r\n                            focusIndex = focusElements.length;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Move to the next component in the set of focus zone components.\r\n            focusIndex += offset;\r\n            // If the FocusZone supports circular navigation and we are on the end\r\n            // we will move to the element on the opposite end.\r\n            if (this.props.circularNavigation) {\r\n                if (focusIndex < 0) {\r\n                    focusIndex = focusElements.length - 1;\r\n                }\r\n                else if (focusIndex >= focusElements.length) {\r\n                    focusIndex = 0;\r\n                }\r\n            }\r\n            // If we ended up on a focusable element update the focus.\r\n            if (focusIndex > -1 && focusIndex < focusElements.length) {\r\n                focusElements[focusIndex].focus();\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    FocusZone.prototype.getFocusElements = function (customSelector) {\r\n        var focusElements = [];\r\n        var selector = customSelector;\r\n        // If a custom selector was supplied we will use it.\r\n        if (!selector) {\r\n            // The default selector will just pick up items tagged with this focuszone id.\r\n            selector = \"[data-focuszone~=\" + this.state.focuszoneId + \"]\";\r\n            // If we are including the default elements from the DOM we will add the\r\n            // default selector to our list of selectors.\r\n            if (this.props.includeDefaults) {\r\n                selector += \",a[href],button,iframe,input,select,textarea,[tabIndex]\";\r\n            }\r\n        }\r\n        // Filter the elements that matched our query to the elements that are elligible\r\n        // for receiving focus in this focuszone.\r\n        for (var _i = 0, _a = this.rootElements; _i < _a.length; _i++) {\r\n            var rootElement = _a[_i];\r\n            if (rootElement.current) {\r\n                var focusChildren = rootElement.current.querySelectorAll(selector);\r\n                // Check if the root element matches our selector.\r\n                if (rootElement.current.matches(selector) && this.isFocusElement(rootElement.current, customSelector)) {\r\n                    focusElements.push(rootElement.current);\r\n                }\r\n                // Check all the children of the root that are potential focus elements.\r\n                for (var rootIndex = 0; rootIndex < focusChildren.length; rootIndex++) {\r\n                    var element = focusChildren[rootIndex];\r\n                    if (this.isFocusElement(element, customSelector)) {\r\n                        focusElements.push(element);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return focusElements;\r\n    };\r\n    /**\r\n     * isFocusElement is used to determine whether or not an element should participate\r\n     * in this focus zone.\r\n     *\r\n     * @param element HTML Element that you are testing as a valid focus element.\r\n     *\r\n     * @param customSelector A custom selector that is used to match elements with\r\n     *  negative tabIndex. These wont match normally unless targetted by the custom\r\n     *  selector.\r\n     */\r\n    FocusZone.prototype.isFocusElement = function (element, customSelector) {\r\n        // Filter out elements that are disabled.\r\n        if (element.hasAttribute(\"disabled\")) {\r\n            return false;\r\n        }\r\n        if (!customSelector) {\r\n            // Filter out elements that are not visible.\r\n            if (!this.props.skipHiddenCheck) {\r\n                var style = window.getComputedStyle(element);\r\n                if (style.visibility === \"hidden\" ||\r\n                    style.display === \"none\" ||\r\n                    !(element.offsetWidth || element.offsetHeight || element.getClientRects().length)) {\r\n                    return false;\r\n                }\r\n            }\r\n            // Filter out elements with negative tabIndex that aren't\r\n            // explicity marked for this focuszone.\r\n            var tabIndex = element.getAttribute(\"tabindex\");\r\n            if (tabIndex && parseInt(tabIndex) < 0) {\r\n                var focuszoneId_1 = element.getAttribute(\"data-focuszone\");\r\n                if (!focuszoneId_1 || focuszoneId_1.indexOf(this.state.focuszoneId) < 0) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    return FocusZone;\r\n}(React.Component));\r\nexport { FocusZone };\r\n"]},"metadata":{},"sourceType":"module"}