{"ast":null,"code":"import { __spreadArrays } from \"tslib\";\n/**\r\n * The TimerManagement class is used to track a set of timers.\r\n */\n\nvar TimerManagement =\n/** @class */\nfunction () {\n  function TimerManagement(parent) {\n    this.disposed = false;\n    this.immediateIds = null;\n    this.intervals = [];\n    this.timeouts = [];\n    this.parent = parent || null;\n  }\n  /**\r\n   * clearAllTimers is used to clear any active timers in the object.\r\n   */\n\n\n  TimerManagement.prototype.clearAllTimers = function () {\n    for (var _i = 0, _a = this.intervals; _i < _a.length; _i++) {\n      var intervalId = _a[_i];\n      window.clearInterval(intervalId);\n    }\n\n    for (var _b = 0, _c = this.timeouts; _b < _c.length; _b++) {\n      var timeoutId = _c[_b];\n      window.clearTimeout(timeoutId);\n    }\n\n    this.intervals.splice(0, this.intervals.length);\n    this.timeouts.splice(0, this.timeouts.length);\n  };\n  /**\r\n   * Clears the immediate.\r\n   * @param id - Id to cancel.\r\n   */\n\n\n  TimerManagement.prototype.clearImmediate = function (id) {\n    if (this.immediateIds && this.immediateIds[id]) {\n      window.clearTimeout(id);\n      delete this.immediateIds[id];\n    }\n  };\n  /**\r\n   * clearInterval is used to stop the series of callbacks that was setup through setInterval.\r\n   *\r\n   * @param intervalId - The id returned from eh setInterval call that you want stopped.\r\n   */\n\n\n  TimerManagement.prototype.clearInterval = function (intervalId) {\n    window.clearInterval(intervalId);\n    this.removeInterval(intervalId);\n  };\n  /**\r\n   * clearTimeout is used to stop a timeout callback that was setup through setTimeout.\r\n   *\r\n   * @param timeoutId - The id returned from the setTimeout call that you want stopped.\r\n   */\n\n\n  TimerManagement.prototype.clearTimeout = function (timeoutId) {\n    window.clearTimeout(timeoutId);\n    this.removeTimeout(timeoutId);\n  };\n  /**\r\n   * SetImmediate override, which will auto cancel the immediate during dispose.\r\n   * @param callback - Callback to execute.\r\n   * @returns The setTimeout id.\r\n   */\n\n\n  TimerManagement.prototype.setImmediate = function (callback) {\n    var _this = this;\n\n    var immediateId = 0;\n\n    if (!this.disposed) {\n      if (!this.immediateIds) {\n        this.immediateIds = {};\n      }\n\n      var setImmediateCallback = function () {\n        // Time to execute the timeout, enqueue it as a foreground task to be executed.\n        try {\n          // Now delete the record and call the callback.\n          if (_this.immediateIds) {\n            delete _this.immediateIds[immediateId];\n          }\n\n          callback.apply(_this.parent);\n        } catch (e) {}\n      };\n\n      immediateId = window.setTimeout(setImmediateCallback, 0);\n      this.immediateIds[immediateId] = true;\n    }\n\n    return immediateId;\n  };\n  /**\r\n   * setInterval is used to setup a callback that is called on an interval.\r\n   *\r\n   * @param callback - The callback that should be called each interval time period.\r\n   *\r\n   * @param milliseconds - The number of milliseconds between each callback.\r\n   *\r\n   * @param args - Optional variable argument list passed to the callback.\r\n   *\r\n   * @returns - returns a handle to the interval, this can be used to cancel through clearInterval method.\r\n   */\n\n\n  TimerManagement.prototype.setInterval = function (callback, milliseconds) {\n    var args = [];\n\n    for (var _i = 2; _i < arguments.length; _i++) {\n      args[_i - 2] = arguments[_i];\n    } // Create the timer, and add a method to track the completion so we can\n    // remove our tracked reference.\n\n\n    var intervalId = window.setInterval.apply(window, __spreadArrays([callback, milliseconds], args));\n    this.intervals.push(intervalId);\n    return intervalId;\n  };\n  /**\r\n   * setTimeout is used to setup a onetime callback that is called after the specified timeout.\r\n   *\r\n   * @param callback - The callback that should be called when the time period has elapsed.\r\n   *\r\n   * @param milliseconds - The number of milliseconds before the callback should be called.\r\n   *  Even if a timeout of 0 is used the callback will be executed asynchronouly.\r\n   *\r\n   * @param args - Optional variable argument list passed to the callback.\r\n   *\r\n   * @returns - returns a handle to the timeout, this can be used to cancel through clearTimeout method.\r\n   */\n\n\n  TimerManagement.prototype.setTimeout = function (callback, milliseconds) {\n    var _this = this;\n\n    var args = [];\n\n    for (var _i = 2; _i < arguments.length; _i++) {\n      args[_i - 2] = arguments[_i];\n    }\n\n    var timeoutId = 0; // Create the timer, and add a method to track the completion so we can\n    // remove our tracked reference.\n\n    timeoutId = window.setTimeout.apply(window, __spreadArrays([function () {\n      _this.removeTimeout(timeoutId);\n\n      callback.apply(void 0, args);\n    }, milliseconds], args));\n    this.timeouts.push(timeoutId);\n    return timeoutId;\n  };\n\n  TimerManagement.prototype.dispose = function () {\n    this.disposed = true;\n    this.parent = null;\n    this.clearAllTimers(); // Clear immediates.\n\n    if (this.immediateIds) {\n      for (var id in this.immediateIds) {\n        if (this.immediateIds.hasOwnProperty(id)) {\n          this.clearImmediate(parseInt(id, 10));\n        }\n      }\n    }\n\n    this.immediateIds = null;\n  };\n  /**\r\n   * Creates a function that will delay the execution of func until after wait milliseconds have\r\n   * elapsed since the last time it was invoked. Provide an options object to indicate that func\r\n   * should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent calls\r\n   * to the debounced function will return the result of the last func call.\r\n   *\r\n   * Note: If leading and trailing options are true func will be called on the trailing edge of\r\n   * the timeout only if the the debounced function is invoked more than once during the wait\r\n   * timeout.\r\n   *\r\n   * @param func - The function to debounce.\r\n   * @param wait - The number of milliseconds to delay.\r\n   * @param options - The options object.\r\n   * @returns The new debounced function.\r\n   */\n\n\n  TimerManagement.prototype.debounce = function (func, wait, options) {\n    var _this = this;\n\n    if (this.disposed) {\n      var noOpFunction = function () {\n        /** Do nothing */\n      };\n\n      noOpFunction.cancel = function () {\n        return;\n      };\n\n      noOpFunction.flush = function () {\n        return null;\n      };\n\n      noOpFunction.pending = function () {\n        return false;\n      };\n\n      return noOpFunction;\n    }\n\n    var waitMS = wait || 0;\n    var leading = false;\n    var trailing = true;\n    var maxWait = null;\n    var lastCallTime = 0;\n    var lastExecuteTime = new Date().getTime();\n    var lastResult;\n    var lastArgs;\n    var timeoutId = null;\n\n    if (options) {\n      leading = options.leading || false;\n      trailing = options.trailing || true;\n      maxWait = options.maxWait || null;\n    }\n\n    var markExecuted = function (time) {\n      if (timeoutId) {\n        _this.clearTimeout(timeoutId);\n\n        timeoutId = null;\n      }\n\n      lastExecuteTime = time;\n    };\n\n    var invokeFunction = function (time) {\n      markExecuted(time);\n      lastResult = func.apply(null, lastArgs);\n    };\n\n    var callback = function (userCall) {\n      var now = new Date().getTime();\n      var executeImmediately = false;\n\n      if (userCall) {\n        if (leading && now - lastCallTime >= waitMS) {\n          executeImmediately = true;\n        }\n\n        lastCallTime = now;\n      }\n\n      var delta = now - lastCallTime;\n      var waitLength = waitMS - delta;\n      var maxWaitDelta = now - lastExecuteTime;\n      var maxWaitExpired = false;\n\n      if (maxWait !== null) {\n        // maxWait only matters when there is a pending callback\n        if (maxWaitDelta >= maxWait && timeoutId) {\n          maxWaitExpired = true;\n        } else {\n          waitLength = Math.min(waitLength, maxWait - maxWaitDelta);\n        }\n      }\n\n      if (delta >= waitMS || maxWaitExpired || executeImmediately) {\n        invokeFunction(now);\n      } else if ((timeoutId === null || !userCall) && trailing) {\n        timeoutId = _this.setTimeout(callback, waitLength);\n      }\n\n      return lastResult;\n    };\n\n    var pending = function () {\n      return !!timeoutId;\n    };\n\n    var cancel = function () {\n      if (pending()) {\n        // Mark the debounced function as having executed\n        markExecuted(new Date().getTime());\n      }\n    };\n\n    var flush = function () {\n      if (pending()) {\n        invokeFunction(new Date().getTime());\n      }\n\n      return lastResult;\n    }; // tslint:disable-next-line:no-any\n\n\n    var resultFunction = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      lastArgs = args;\n      return callback(true);\n    };\n\n    resultFunction.cancel = cancel;\n    resultFunction.flush = flush;\n    resultFunction.pending = pending;\n    return resultFunction;\n  };\n  /**\r\n   * Creates a function that, when executed, will only call the func function at most once per\r\n   * every wait milliseconds. Provide an options object to indicate that func should be invoked\r\n   * on the leading and/or trailing edge of the wait timeout. Subsequent calls to the throttled\r\n   * function will return the result of the last func call.\r\n   *\r\n   * Note: If leading and trailing options are true func will be called on the trailing edge of\r\n   * the timeout only if the the throttled function is invoked more than once during the wait timeout.\r\n   *\r\n   * @param func - The function to throttle.\r\n   * @param wait - The number of milliseconds to throttle executions to. Defaults to 0.\r\n   * @param options - The options object.\r\n   * @returns The new throttled function.\r\n   */\n\n\n  TimerManagement.prototype.throttle = function (func, wait, options) {\n    var _this = this;\n\n    if (this.disposed) {\n      var noOpFunction = function () {\n        /** Do nothing */\n      };\n\n      noOpFunction.cancel = function () {\n        return;\n      };\n\n      noOpFunction.flush = function () {\n        return null;\n      };\n\n      noOpFunction.pending = function () {\n        return false;\n      };\n\n      return noOpFunction;\n    }\n\n    var waitMS = wait || 0;\n    var leading = true;\n    var trailing = true;\n    var lastExecuteTime = 0;\n    var lastResult; // tslint:disable-next-line:no-any\n\n    var lastArgs;\n    var timeoutId = null;\n\n    if (options && typeof options.leading === \"boolean\") {\n      leading = options.leading;\n    }\n\n    if (options && typeof options.trailing === \"boolean\") {\n      trailing = options.trailing;\n    }\n\n    var callback = function (userCall) {\n      var now = new Date().getTime();\n      var delta = now - lastExecuteTime;\n      var waitLength = leading ? waitMS - delta : waitMS;\n\n      if (delta >= waitMS && (!userCall || leading)) {\n        lastExecuteTime = now;\n\n        if (timeoutId) {\n          _this.clearTimeout(timeoutId);\n\n          timeoutId = null;\n        }\n\n        lastResult = func.apply(null, lastArgs);\n      } else if (timeoutId === null && trailing) {\n        timeoutId = _this.setTimeout(callback, waitLength);\n      }\n\n      return lastResult;\n    }; // tslint:disable-next-line:no-any\n\n\n    var resultFunction = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      lastArgs = args;\n      return callback(true);\n    };\n\n    return resultFunction;\n  };\n\n  TimerManagement.prototype.removeInterval = function (intervalId) {\n    var index = this.intervals.indexOf(intervalId);\n\n    if (index >= 0) {\n      this.intervals.splice(index, 1);\n    }\n  };\n\n  TimerManagement.prototype.removeTimeout = function (timeoutId) {\n    var index = this.timeouts.indexOf(timeoutId);\n\n    if (index >= 0) {\n      this.timeouts.splice(index, 1);\n    }\n  };\n\n  return TimerManagement;\n}();\n\nexport { TimerManagement };","map":{"version":3,"sources":["/Users/ayounghosh/Downloads/Create_Work_Item_Azure_Devops/Front_End/node_modules/azure-devops-ui/Core/TimerManagement.js"],"names":["__spreadArrays","TimerManagement","parent","disposed","immediateIds","intervals","timeouts","prototype","clearAllTimers","_i","_a","length","intervalId","window","clearInterval","_b","_c","timeoutId","clearTimeout","splice","clearImmediate","id","removeInterval","removeTimeout","setImmediate","callback","_this","immediateId","setImmediateCallback","apply","e","setTimeout","setInterval","milliseconds","args","arguments","push","dispose","hasOwnProperty","parseInt","debounce","func","wait","options","noOpFunction","cancel","flush","pending","waitMS","leading","trailing","maxWait","lastCallTime","lastExecuteTime","Date","getTime","lastResult","lastArgs","markExecuted","time","invokeFunction","userCall","now","executeImmediately","delta","waitLength","maxWaitDelta","maxWaitExpired","Math","min","resultFunction","throttle","index","indexOf"],"mappings":"AAAA,SAASA,cAAT,QAA+B,OAA/B;AACA;AACA;AACA;;AACA,IAAIC,eAAe;AAAG;AAAe,YAAY;AAC7C,WAASA,eAAT,CAAyBC,MAAzB,EAAiC;AAC7B,SAAKC,QAAL,GAAgB,KAAhB;AACA,SAAKC,YAAL,GAAoB,IAApB;AACA,SAAKC,SAAL,GAAiB,EAAjB;AACA,SAAKC,QAAL,GAAgB,EAAhB;AACA,SAAKJ,MAAL,GAAcA,MAAM,IAAI,IAAxB;AACH;AACD;AACJ;AACA;;;AACID,EAAAA,eAAe,CAACM,SAAhB,CAA0BC,cAA1B,GAA2C,YAAY;AACnD,SAAK,IAAIC,EAAE,GAAG,CAAT,EAAYC,EAAE,GAAG,KAAKL,SAA3B,EAAsCI,EAAE,GAAGC,EAAE,CAACC,MAA9C,EAAsDF,EAAE,EAAxD,EAA4D;AACxD,UAAIG,UAAU,GAAGF,EAAE,CAACD,EAAD,CAAnB;AACAI,MAAAA,MAAM,CAACC,aAAP,CAAqBF,UAArB;AACH;;AACD,SAAK,IAAIG,EAAE,GAAG,CAAT,EAAYC,EAAE,GAAG,KAAKV,QAA3B,EAAqCS,EAAE,GAAGC,EAAE,CAACL,MAA7C,EAAqDI,EAAE,EAAvD,EAA2D;AACvD,UAAIE,SAAS,GAAGD,EAAE,CAACD,EAAD,CAAlB;AACAF,MAAAA,MAAM,CAACK,YAAP,CAAoBD,SAApB;AACH;;AACD,SAAKZ,SAAL,CAAec,MAAf,CAAsB,CAAtB,EAAyB,KAAKd,SAAL,CAAeM,MAAxC;AACA,SAAKL,QAAL,CAAca,MAAd,CAAqB,CAArB,EAAwB,KAAKb,QAAL,CAAcK,MAAtC;AACH,GAXD;AAYA;AACJ;AACA;AACA;;;AACIV,EAAAA,eAAe,CAACM,SAAhB,CAA0Ba,cAA1B,GAA2C,UAAUC,EAAV,EAAc;AACrD,QAAI,KAAKjB,YAAL,IAAqB,KAAKA,YAAL,CAAkBiB,EAAlB,CAAzB,EAAgD;AAC5CR,MAAAA,MAAM,CAACK,YAAP,CAAoBG,EAApB;AACA,aAAO,KAAKjB,YAAL,CAAkBiB,EAAlB,CAAP;AACH;AACJ,GALD;AAMA;AACJ;AACA;AACA;AACA;;;AACIpB,EAAAA,eAAe,CAACM,SAAhB,CAA0BO,aAA1B,GAA0C,UAAUF,UAAV,EAAsB;AAC5DC,IAAAA,MAAM,CAACC,aAAP,CAAqBF,UAArB;AACA,SAAKU,cAAL,CAAoBV,UAApB;AACH,GAHD;AAIA;AACJ;AACA;AACA;AACA;;;AACIX,EAAAA,eAAe,CAACM,SAAhB,CAA0BW,YAA1B,GAAyC,UAAUD,SAAV,EAAqB;AAC1DJ,IAAAA,MAAM,CAACK,YAAP,CAAoBD,SAApB;AACA,SAAKM,aAAL,CAAmBN,SAAnB;AACH,GAHD;AAIA;AACJ;AACA;AACA;AACA;;;AACIhB,EAAAA,eAAe,CAACM,SAAhB,CAA0BiB,YAA1B,GAAyC,UAAUC,QAAV,EAAoB;AACzD,QAAIC,KAAK,GAAG,IAAZ;;AACA,QAAIC,WAAW,GAAG,CAAlB;;AACA,QAAI,CAAC,KAAKxB,QAAV,EAAoB;AAChB,UAAI,CAAC,KAAKC,YAAV,EAAwB;AACpB,aAAKA,YAAL,GAAoB,EAApB;AACH;;AACD,UAAIwB,oBAAoB,GAAG,YAAY;AACnC;AACA,YAAI;AACA;AACA,cAAIF,KAAK,CAACtB,YAAV,EAAwB;AACpB,mBAAOsB,KAAK,CAACtB,YAAN,CAAmBuB,WAAnB,CAAP;AACH;;AACDF,UAAAA,QAAQ,CAACI,KAAT,CAAeH,KAAK,CAACxB,MAArB;AACH,SAND,CAOA,OAAO4B,CAAP,EAAU,CAAG;AAChB,OAVD;;AAWAH,MAAAA,WAAW,GAAGd,MAAM,CAACkB,UAAP,CAAkBH,oBAAlB,EAAwC,CAAxC,CAAd;AACA,WAAKxB,YAAL,CAAkBuB,WAAlB,IAAiC,IAAjC;AACH;;AACD,WAAOA,WAAP;AACH,GAtBD;AAuBA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI1B,EAAAA,eAAe,CAACM,SAAhB,CAA0ByB,WAA1B,GAAwC,UAAUP,QAAV,EAAoBQ,YAApB,EAAkC;AACtE,QAAIC,IAAI,GAAG,EAAX;;AACA,SAAK,IAAIzB,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAG0B,SAAS,CAACxB,MAAhC,EAAwCF,EAAE,EAA1C,EAA8C;AAC1CyB,MAAAA,IAAI,CAACzB,EAAE,GAAG,CAAN,CAAJ,GAAe0B,SAAS,CAAC1B,EAAD,CAAxB;AACH,KAJqE,CAKtE;AACA;;;AACA,QAAIG,UAAU,GAAGC,MAAM,CAACmB,WAAP,CAAmBH,KAAnB,CAAyBhB,MAAzB,EAAiCb,cAAc,CAAC,CAACyB,QAAD,EAAWQ,YAAX,CAAD,EAA2BC,IAA3B,CAA/C,CAAjB;AACA,SAAK7B,SAAL,CAAe+B,IAAf,CAAoBxB,UAApB;AACA,WAAOA,UAAP;AACH,GAVD;AAWA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIX,EAAAA,eAAe,CAACM,SAAhB,CAA0BwB,UAA1B,GAAuC,UAAUN,QAAV,EAAoBQ,YAApB,EAAkC;AACrE,QAAIP,KAAK,GAAG,IAAZ;;AACA,QAAIQ,IAAI,GAAG,EAAX;;AACA,SAAK,IAAIzB,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAG0B,SAAS,CAACxB,MAAhC,EAAwCF,EAAE,EAA1C,EAA8C;AAC1CyB,MAAAA,IAAI,CAACzB,EAAE,GAAG,CAAN,CAAJ,GAAe0B,SAAS,CAAC1B,EAAD,CAAxB;AACH;;AACD,QAAIQ,SAAS,GAAG,CAAhB,CANqE,CAOrE;AACA;;AACAA,IAAAA,SAAS,GAAGJ,MAAM,CAACkB,UAAP,CAAkBF,KAAlB,CAAwBhB,MAAxB,EAAgCb,cAAc,CAAC,CAAC,YAAY;AAChE0B,MAAAA,KAAK,CAACH,aAAN,CAAoBN,SAApB;;AACAQ,MAAAA,QAAQ,CAACI,KAAT,CAAe,KAAK,CAApB,EAAuBK,IAAvB;AACH,KAHsD,EAIvDD,YAJuD,CAAD,EAIvCC,IAJuC,CAA9C,CAAZ;AAKA,SAAK5B,QAAL,CAAc8B,IAAd,CAAmBnB,SAAnB;AACA,WAAOA,SAAP;AACH,GAhBD;;AAiBAhB,EAAAA,eAAe,CAACM,SAAhB,CAA0B8B,OAA1B,GAAoC,YAAY;AAC5C,SAAKlC,QAAL,GAAgB,IAAhB;AACA,SAAKD,MAAL,GAAc,IAAd;AACA,SAAKM,cAAL,GAH4C,CAI5C;;AACA,QAAI,KAAKJ,YAAT,EAAuB;AACnB,WAAK,IAAIiB,EAAT,IAAe,KAAKjB,YAApB,EAAkC;AAC9B,YAAI,KAAKA,YAAL,CAAkBkC,cAAlB,CAAiCjB,EAAjC,CAAJ,EAA0C;AACtC,eAAKD,cAAL,CAAoBmB,QAAQ,CAAClB,EAAD,EAAK,EAAL,CAA5B;AACH;AACJ;AACJ;;AACD,SAAKjB,YAAL,GAAoB,IAApB;AACH,GAbD;AAcA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIH,EAAAA,eAAe,CAACM,SAAhB,CAA0BiC,QAA1B,GAAqC,UAAUC,IAAV,EAAgBC,IAAhB,EAAsBC,OAAtB,EAA+B;AAChE,QAAIjB,KAAK,GAAG,IAAZ;;AACA,QAAI,KAAKvB,QAAT,EAAmB;AACf,UAAIyC,YAAY,GAAI,YAAY;AAC5B;AACH,OAFD;;AAGAA,MAAAA,YAAY,CAACC,MAAb,GAAsB,YAAY;AAC9B;AACH,OAFD;;AAGAD,MAAAA,YAAY,CAACE,KAAb,GAAsB,YAAY;AAAE,eAAO,IAAP;AAAc,OAAlD;;AACAF,MAAAA,YAAY,CAACG,OAAb,GAAuB,YAAY;AAAE,eAAO,KAAP;AAAe,OAApD;;AACA,aAAOH,YAAP;AACH;;AACD,QAAII,MAAM,GAAGN,IAAI,IAAI,CAArB;AACA,QAAIO,OAAO,GAAG,KAAd;AACA,QAAIC,QAAQ,GAAG,IAAf;AACA,QAAIC,OAAO,GAAG,IAAd;AACA,QAAIC,YAAY,GAAG,CAAnB;AACA,QAAIC,eAAe,GAAG,IAAIC,IAAJ,GAAWC,OAAX,EAAtB;AACA,QAAIC,UAAJ;AACA,QAAIC,QAAJ;AACA,QAAIxC,SAAS,GAAG,IAAhB;;AACA,QAAI0B,OAAJ,EAAa;AACTM,MAAAA,OAAO,GAAGN,OAAO,CAACM,OAAR,IAAmB,KAA7B;AACAC,MAAAA,QAAQ,GAAGP,OAAO,CAACO,QAAR,IAAoB,IAA/B;AACAC,MAAAA,OAAO,GAAGR,OAAO,CAACQ,OAAR,IAAmB,IAA7B;AACH;;AACD,QAAIO,YAAY,GAAG,UAAUC,IAAV,EAAgB;AAC/B,UAAI1C,SAAJ,EAAe;AACXS,QAAAA,KAAK,CAACR,YAAN,CAAmBD,SAAnB;;AACAA,QAAAA,SAAS,GAAG,IAAZ;AACH;;AACDoC,MAAAA,eAAe,GAAGM,IAAlB;AACH,KAND;;AAOA,QAAIC,cAAc,GAAG,UAAUD,IAAV,EAAgB;AACjCD,MAAAA,YAAY,CAACC,IAAD,CAAZ;AACAH,MAAAA,UAAU,GAAGf,IAAI,CAACZ,KAAL,CAAW,IAAX,EAAiB4B,QAAjB,CAAb;AACH,KAHD;;AAIA,QAAIhC,QAAQ,GAAG,UAAUoC,QAAV,EAAoB;AAC/B,UAAIC,GAAG,GAAG,IAAIR,IAAJ,GAAWC,OAAX,EAAV;AACA,UAAIQ,kBAAkB,GAAG,KAAzB;;AACA,UAAIF,QAAJ,EAAc;AACV,YAAIZ,OAAO,IAAIa,GAAG,GAAGV,YAAN,IAAsBJ,MAArC,EAA6C;AACzCe,UAAAA,kBAAkB,GAAG,IAArB;AACH;;AACDX,QAAAA,YAAY,GAAGU,GAAf;AACH;;AACD,UAAIE,KAAK,GAAGF,GAAG,GAAGV,YAAlB;AACA,UAAIa,UAAU,GAAGjB,MAAM,GAAGgB,KAA1B;AACA,UAAIE,YAAY,GAAGJ,GAAG,GAAGT,eAAzB;AACA,UAAIc,cAAc,GAAG,KAArB;;AACA,UAAIhB,OAAO,KAAK,IAAhB,EAAsB;AAClB;AACA,YAAIe,YAAY,IAAIf,OAAhB,IAA2BlC,SAA/B,EAA0C;AACtCkD,UAAAA,cAAc,GAAG,IAAjB;AACH,SAFD,MAGK;AACDF,UAAAA,UAAU,GAAGG,IAAI,CAACC,GAAL,CAASJ,UAAT,EAAqBd,OAAO,GAAGe,YAA/B,CAAb;AACH;AACJ;;AACD,UAAIF,KAAK,IAAIhB,MAAT,IAAmBmB,cAAnB,IAAqCJ,kBAAzC,EAA6D;AACzDH,QAAAA,cAAc,CAACE,GAAD,CAAd;AACH,OAFD,MAGK,IAAI,CAAC7C,SAAS,KAAK,IAAd,IAAsB,CAAC4C,QAAxB,KAAqCX,QAAzC,EAAmD;AACpDjC,QAAAA,SAAS,GAAGS,KAAK,CAACK,UAAN,CAAiBN,QAAjB,EAA2BwC,UAA3B,CAAZ;AACH;;AACD,aAAOT,UAAP;AACH,KA7BD;;AA8BA,QAAIT,OAAO,GAAG,YAAY;AACtB,aAAO,CAAC,CAAC9B,SAAT;AACH,KAFD;;AAGA,QAAI4B,MAAM,GAAG,YAAY;AACrB,UAAIE,OAAO,EAAX,EAAe;AACX;AACAW,QAAAA,YAAY,CAAC,IAAIJ,IAAJ,GAAWC,OAAX,EAAD,CAAZ;AACH;AACJ,KALD;;AAMA,QAAIT,KAAK,GAAG,YAAY;AACpB,UAAIC,OAAO,EAAX,EAAe;AACXa,QAAAA,cAAc,CAAC,IAAIN,IAAJ,GAAWC,OAAX,EAAD,CAAd;AACH;;AACD,aAAOC,UAAP;AACH,KALD,CA7EgE,CAmFhE;;;AACA,QAAIc,cAAc,GAAI,YAAY;AAC9B,UAAIpC,IAAI,GAAG,EAAX;;AACA,WAAK,IAAIzB,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAG0B,SAAS,CAACxB,MAAhC,EAAwCF,EAAE,EAA1C,EAA8C;AAC1CyB,QAAAA,IAAI,CAACzB,EAAD,CAAJ,GAAW0B,SAAS,CAAC1B,EAAD,CAApB;AACH;;AACDgD,MAAAA,QAAQ,GAAGvB,IAAX;AACA,aAAOT,QAAQ,CAAC,IAAD,CAAf;AACH,KAPD;;AAQA6C,IAAAA,cAAc,CAACzB,MAAf,GAAwBA,MAAxB;AACAyB,IAAAA,cAAc,CAACxB,KAAf,GAAuBA,KAAvB;AACAwB,IAAAA,cAAc,CAACvB,OAAf,GAAyBA,OAAzB;AACA,WAAOuB,cAAP;AACH,GAhGD;AAiGA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIrE,EAAAA,eAAe,CAACM,SAAhB,CAA0BgE,QAA1B,GAAqC,UAAU9B,IAAV,EAAgBC,IAAhB,EAAsBC,OAAtB,EAA+B;AAChE,QAAIjB,KAAK,GAAG,IAAZ;;AACA,QAAI,KAAKvB,QAAT,EAAmB;AACf,UAAIyC,YAAY,GAAI,YAAY;AAC5B;AACH,OAFD;;AAGAA,MAAAA,YAAY,CAACC,MAAb,GAAsB,YAAY;AAC9B;AACH,OAFD;;AAGAD,MAAAA,YAAY,CAACE,KAAb,GAAsB,YAAY;AAAE,eAAO,IAAP;AAAc,OAAlD;;AACAF,MAAAA,YAAY,CAACG,OAAb,GAAuB,YAAY;AAAE,eAAO,KAAP;AAAe,OAApD;;AACA,aAAOH,YAAP;AACH;;AACD,QAAII,MAAM,GAAGN,IAAI,IAAI,CAArB;AACA,QAAIO,OAAO,GAAG,IAAd;AACA,QAAIC,QAAQ,GAAG,IAAf;AACA,QAAIG,eAAe,GAAG,CAAtB;AACA,QAAIG,UAAJ,CAjBgE,CAkBhE;;AACA,QAAIC,QAAJ;AACA,QAAIxC,SAAS,GAAG,IAAhB;;AACA,QAAI0B,OAAO,IAAI,OAAOA,OAAO,CAACM,OAAf,KAA2B,SAA1C,EAAqD;AACjDA,MAAAA,OAAO,GAAGN,OAAO,CAACM,OAAlB;AACH;;AACD,QAAIN,OAAO,IAAI,OAAOA,OAAO,CAACO,QAAf,KAA4B,SAA3C,EAAsD;AAClDA,MAAAA,QAAQ,GAAGP,OAAO,CAACO,QAAnB;AACH;;AACD,QAAIzB,QAAQ,GAAG,UAAUoC,QAAV,EAAoB;AAC/B,UAAIC,GAAG,GAAG,IAAIR,IAAJ,GAAWC,OAAX,EAAV;AACA,UAAIS,KAAK,GAAGF,GAAG,GAAGT,eAAlB;AACA,UAAIY,UAAU,GAAGhB,OAAO,GAAGD,MAAM,GAAGgB,KAAZ,GAAoBhB,MAA5C;;AACA,UAAIgB,KAAK,IAAIhB,MAAT,KAAoB,CAACa,QAAD,IAAaZ,OAAjC,CAAJ,EAA+C;AAC3CI,QAAAA,eAAe,GAAGS,GAAlB;;AACA,YAAI7C,SAAJ,EAAe;AACXS,UAAAA,KAAK,CAACR,YAAN,CAAmBD,SAAnB;;AACAA,UAAAA,SAAS,GAAG,IAAZ;AACH;;AACDuC,QAAAA,UAAU,GAAGf,IAAI,CAACZ,KAAL,CAAW,IAAX,EAAiB4B,QAAjB,CAAb;AACH,OAPD,MAQK,IAAIxC,SAAS,KAAK,IAAd,IAAsBiC,QAA1B,EAAoC;AACrCjC,QAAAA,SAAS,GAAGS,KAAK,CAACK,UAAN,CAAiBN,QAAjB,EAA2BwC,UAA3B,CAAZ;AACH;;AACD,aAAOT,UAAP;AACH,KAhBD,CA3BgE,CA4ChE;;;AACA,QAAIc,cAAc,GAAG,YAAY;AAC7B,UAAIpC,IAAI,GAAG,EAAX;;AACA,WAAK,IAAIzB,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAG0B,SAAS,CAACxB,MAAhC,EAAwCF,EAAE,EAA1C,EAA8C;AAC1CyB,QAAAA,IAAI,CAACzB,EAAD,CAAJ,GAAW0B,SAAS,CAAC1B,EAAD,CAApB;AACH;;AACDgD,MAAAA,QAAQ,GAAGvB,IAAX;AACA,aAAOT,QAAQ,CAAC,IAAD,CAAf;AACH,KAPD;;AAQA,WAAO6C,cAAP;AACH,GAtDD;;AAuDArE,EAAAA,eAAe,CAACM,SAAhB,CAA0Be,cAA1B,GAA2C,UAAUV,UAAV,EAAsB;AAC7D,QAAI4D,KAAK,GAAG,KAAKnE,SAAL,CAAeoE,OAAf,CAAuB7D,UAAvB,CAAZ;;AACA,QAAI4D,KAAK,IAAI,CAAb,EAAgB;AACZ,WAAKnE,SAAL,CAAec,MAAf,CAAsBqD,KAAtB,EAA6B,CAA7B;AACH;AACJ,GALD;;AAMAvE,EAAAA,eAAe,CAACM,SAAhB,CAA0BgB,aAA1B,GAA0C,UAAUN,SAAV,EAAqB;AAC3D,QAAIuD,KAAK,GAAG,KAAKlE,QAAL,CAAcmE,OAAd,CAAsBxD,SAAtB,CAAZ;;AACA,QAAIuD,KAAK,IAAI,CAAb,EAAgB;AACZ,WAAKlE,QAAL,CAAca,MAAd,CAAqBqD,KAArB,EAA4B,CAA5B;AACH;AACJ,GALD;;AAMA,SAAOvE,eAAP;AACH,CAlVoC,EAArC;;AAmVA,SAASA,eAAT","sourcesContent":["import { __spreadArrays } from \"tslib\";\r\n/**\r\n * The TimerManagement class is used to track a set of timers.\r\n */\r\nvar TimerManagement = /** @class */ (function () {\r\n    function TimerManagement(parent) {\r\n        this.disposed = false;\r\n        this.immediateIds = null;\r\n        this.intervals = [];\r\n        this.timeouts = [];\r\n        this.parent = parent || null;\r\n    }\r\n    /**\r\n     * clearAllTimers is used to clear any active timers in the object.\r\n     */\r\n    TimerManagement.prototype.clearAllTimers = function () {\r\n        for (var _i = 0, _a = this.intervals; _i < _a.length; _i++) {\r\n            var intervalId = _a[_i];\r\n            window.clearInterval(intervalId);\r\n        }\r\n        for (var _b = 0, _c = this.timeouts; _b < _c.length; _b++) {\r\n            var timeoutId = _c[_b];\r\n            window.clearTimeout(timeoutId);\r\n        }\r\n        this.intervals.splice(0, this.intervals.length);\r\n        this.timeouts.splice(0, this.timeouts.length);\r\n    };\r\n    /**\r\n     * Clears the immediate.\r\n     * @param id - Id to cancel.\r\n     */\r\n    TimerManagement.prototype.clearImmediate = function (id) {\r\n        if (this.immediateIds && this.immediateIds[id]) {\r\n            window.clearTimeout(id);\r\n            delete this.immediateIds[id];\r\n        }\r\n    };\r\n    /**\r\n     * clearInterval is used to stop the series of callbacks that was setup through setInterval.\r\n     *\r\n     * @param intervalId - The id returned from eh setInterval call that you want stopped.\r\n     */\r\n    TimerManagement.prototype.clearInterval = function (intervalId) {\r\n        window.clearInterval(intervalId);\r\n        this.removeInterval(intervalId);\r\n    };\r\n    /**\r\n     * clearTimeout is used to stop a timeout callback that was setup through setTimeout.\r\n     *\r\n     * @param timeoutId - The id returned from the setTimeout call that you want stopped.\r\n     */\r\n    TimerManagement.prototype.clearTimeout = function (timeoutId) {\r\n        window.clearTimeout(timeoutId);\r\n        this.removeTimeout(timeoutId);\r\n    };\r\n    /**\r\n     * SetImmediate override, which will auto cancel the immediate during dispose.\r\n     * @param callback - Callback to execute.\r\n     * @returns The setTimeout id.\r\n     */\r\n    TimerManagement.prototype.setImmediate = function (callback) {\r\n        var _this = this;\r\n        var immediateId = 0;\r\n        if (!this.disposed) {\r\n            if (!this.immediateIds) {\r\n                this.immediateIds = {};\r\n            }\r\n            var setImmediateCallback = function () {\r\n                // Time to execute the timeout, enqueue it as a foreground task to be executed.\r\n                try {\r\n                    // Now delete the record and call the callback.\r\n                    if (_this.immediateIds) {\r\n                        delete _this.immediateIds[immediateId];\r\n                    }\r\n                    callback.apply(_this.parent);\r\n                }\r\n                catch (e) { }\r\n            };\r\n            immediateId = window.setTimeout(setImmediateCallback, 0);\r\n            this.immediateIds[immediateId] = true;\r\n        }\r\n        return immediateId;\r\n    };\r\n    /**\r\n     * setInterval is used to setup a callback that is called on an interval.\r\n     *\r\n     * @param callback - The callback that should be called each interval time period.\r\n     *\r\n     * @param milliseconds - The number of milliseconds between each callback.\r\n     *\r\n     * @param args - Optional variable argument list passed to the callback.\r\n     *\r\n     * @returns - returns a handle to the interval, this can be used to cancel through clearInterval method.\r\n     */\r\n    TimerManagement.prototype.setInterval = function (callback, milliseconds) {\r\n        var args = [];\r\n        for (var _i = 2; _i < arguments.length; _i++) {\r\n            args[_i - 2] = arguments[_i];\r\n        }\r\n        // Create the timer, and add a method to track the completion so we can\r\n        // remove our tracked reference.\r\n        var intervalId = window.setInterval.apply(window, __spreadArrays([callback, milliseconds], args));\r\n        this.intervals.push(intervalId);\r\n        return intervalId;\r\n    };\r\n    /**\r\n     * setTimeout is used to setup a onetime callback that is called after the specified timeout.\r\n     *\r\n     * @param callback - The callback that should be called when the time period has elapsed.\r\n     *\r\n     * @param milliseconds - The number of milliseconds before the callback should be called.\r\n     *  Even if a timeout of 0 is used the callback will be executed asynchronouly.\r\n     *\r\n     * @param args - Optional variable argument list passed to the callback.\r\n     *\r\n     * @returns - returns a handle to the timeout, this can be used to cancel through clearTimeout method.\r\n     */\r\n    TimerManagement.prototype.setTimeout = function (callback, milliseconds) {\r\n        var _this = this;\r\n        var args = [];\r\n        for (var _i = 2; _i < arguments.length; _i++) {\r\n            args[_i - 2] = arguments[_i];\r\n        }\r\n        var timeoutId = 0;\r\n        // Create the timer, and add a method to track the completion so we can\r\n        // remove our tracked reference.\r\n        timeoutId = window.setTimeout.apply(window, __spreadArrays([function () {\r\n                _this.removeTimeout(timeoutId);\r\n                callback.apply(void 0, args);\r\n            },\r\n            milliseconds], args));\r\n        this.timeouts.push(timeoutId);\r\n        return timeoutId;\r\n    };\r\n    TimerManagement.prototype.dispose = function () {\r\n        this.disposed = true;\r\n        this.parent = null;\r\n        this.clearAllTimers();\r\n        // Clear immediates.\r\n        if (this.immediateIds) {\r\n            for (var id in this.immediateIds) {\r\n                if (this.immediateIds.hasOwnProperty(id)) {\r\n                    this.clearImmediate(parseInt(id, 10));\r\n                }\r\n            }\r\n        }\r\n        this.immediateIds = null;\r\n    };\r\n    /**\r\n     * Creates a function that will delay the execution of func until after wait milliseconds have\r\n     * elapsed since the last time it was invoked. Provide an options object to indicate that func\r\n     * should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent calls\r\n     * to the debounced function will return the result of the last func call.\r\n     *\r\n     * Note: If leading and trailing options are true func will be called on the trailing edge of\r\n     * the timeout only if the the debounced function is invoked more than once during the wait\r\n     * timeout.\r\n     *\r\n     * @param func - The function to debounce.\r\n     * @param wait - The number of milliseconds to delay.\r\n     * @param options - The options object.\r\n     * @returns The new debounced function.\r\n     */\r\n    TimerManagement.prototype.debounce = function (func, wait, options) {\r\n        var _this = this;\r\n        if (this.disposed) {\r\n            var noOpFunction = (function () {\r\n                /** Do nothing */\r\n            });\r\n            noOpFunction.cancel = function () {\r\n                return;\r\n            };\r\n            noOpFunction.flush = (function () { return null; });\r\n            noOpFunction.pending = function () { return false; };\r\n            return noOpFunction;\r\n        }\r\n        var waitMS = wait || 0;\r\n        var leading = false;\r\n        var trailing = true;\r\n        var maxWait = null;\r\n        var lastCallTime = 0;\r\n        var lastExecuteTime = new Date().getTime();\r\n        var lastResult;\r\n        var lastArgs;\r\n        var timeoutId = null;\r\n        if (options) {\r\n            leading = options.leading || false;\r\n            trailing = options.trailing || true;\r\n            maxWait = options.maxWait || null;\r\n        }\r\n        var markExecuted = function (time) {\r\n            if (timeoutId) {\r\n                _this.clearTimeout(timeoutId);\r\n                timeoutId = null;\r\n            }\r\n            lastExecuteTime = time;\r\n        };\r\n        var invokeFunction = function (time) {\r\n            markExecuted(time);\r\n            lastResult = func.apply(null, lastArgs);\r\n        };\r\n        var callback = function (userCall) {\r\n            var now = new Date().getTime();\r\n            var executeImmediately = false;\r\n            if (userCall) {\r\n                if (leading && now - lastCallTime >= waitMS) {\r\n                    executeImmediately = true;\r\n                }\r\n                lastCallTime = now;\r\n            }\r\n            var delta = now - lastCallTime;\r\n            var waitLength = waitMS - delta;\r\n            var maxWaitDelta = now - lastExecuteTime;\r\n            var maxWaitExpired = false;\r\n            if (maxWait !== null) {\r\n                // maxWait only matters when there is a pending callback\r\n                if (maxWaitDelta >= maxWait && timeoutId) {\r\n                    maxWaitExpired = true;\r\n                }\r\n                else {\r\n                    waitLength = Math.min(waitLength, maxWait - maxWaitDelta);\r\n                }\r\n            }\r\n            if (delta >= waitMS || maxWaitExpired || executeImmediately) {\r\n                invokeFunction(now);\r\n            }\r\n            else if ((timeoutId === null || !userCall) && trailing) {\r\n                timeoutId = _this.setTimeout(callback, waitLength);\r\n            }\r\n            return lastResult;\r\n        };\r\n        var pending = function () {\r\n            return !!timeoutId;\r\n        };\r\n        var cancel = function () {\r\n            if (pending()) {\r\n                // Mark the debounced function as having executed\r\n                markExecuted(new Date().getTime());\r\n            }\r\n        };\r\n        var flush = function () {\r\n            if (pending()) {\r\n                invokeFunction(new Date().getTime());\r\n            }\r\n            return lastResult;\r\n        };\r\n        // tslint:disable-next-line:no-any\r\n        var resultFunction = (function () {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            lastArgs = args;\r\n            return callback(true);\r\n        });\r\n        resultFunction.cancel = cancel;\r\n        resultFunction.flush = flush;\r\n        resultFunction.pending = pending;\r\n        return resultFunction;\r\n    };\r\n    /**\r\n     * Creates a function that, when executed, will only call the func function at most once per\r\n     * every wait milliseconds. Provide an options object to indicate that func should be invoked\r\n     * on the leading and/or trailing edge of the wait timeout. Subsequent calls to the throttled\r\n     * function will return the result of the last func call.\r\n     *\r\n     * Note: If leading and trailing options are true func will be called on the trailing edge of\r\n     * the timeout only if the the throttled function is invoked more than once during the wait timeout.\r\n     *\r\n     * @param func - The function to throttle.\r\n     * @param wait - The number of milliseconds to throttle executions to. Defaults to 0.\r\n     * @param options - The options object.\r\n     * @returns The new throttled function.\r\n     */\r\n    TimerManagement.prototype.throttle = function (func, wait, options) {\r\n        var _this = this;\r\n        if (this.disposed) {\r\n            var noOpFunction = (function () {\r\n                /** Do nothing */\r\n            });\r\n            noOpFunction.cancel = function () {\r\n                return;\r\n            };\r\n            noOpFunction.flush = (function () { return null; });\r\n            noOpFunction.pending = function () { return false; };\r\n            return noOpFunction;\r\n        }\r\n        var waitMS = wait || 0;\r\n        var leading = true;\r\n        var trailing = true;\r\n        var lastExecuteTime = 0;\r\n        var lastResult;\r\n        // tslint:disable-next-line:no-any\r\n        var lastArgs;\r\n        var timeoutId = null;\r\n        if (options && typeof options.leading === \"boolean\") {\r\n            leading = options.leading;\r\n        }\r\n        if (options && typeof options.trailing === \"boolean\") {\r\n            trailing = options.trailing;\r\n        }\r\n        var callback = function (userCall) {\r\n            var now = new Date().getTime();\r\n            var delta = now - lastExecuteTime;\r\n            var waitLength = leading ? waitMS - delta : waitMS;\r\n            if (delta >= waitMS && (!userCall || leading)) {\r\n                lastExecuteTime = now;\r\n                if (timeoutId) {\r\n                    _this.clearTimeout(timeoutId);\r\n                    timeoutId = null;\r\n                }\r\n                lastResult = func.apply(null, lastArgs);\r\n            }\r\n            else if (timeoutId === null && trailing) {\r\n                timeoutId = _this.setTimeout(callback, waitLength);\r\n            }\r\n            return lastResult;\r\n        };\r\n        // tslint:disable-next-line:no-any\r\n        var resultFunction = function () {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            lastArgs = args;\r\n            return callback(true);\r\n        };\r\n        return resultFunction;\r\n    };\r\n    TimerManagement.prototype.removeInterval = function (intervalId) {\r\n        var index = this.intervals.indexOf(intervalId);\r\n        if (index >= 0) {\r\n            this.intervals.splice(index, 1);\r\n        }\r\n    };\r\n    TimerManagement.prototype.removeTimeout = function (timeoutId) {\r\n        var index = this.timeouts.indexOf(timeoutId);\r\n        if (index >= 0) {\r\n            this.timeouts.splice(index, 1);\r\n        }\r\n    };\r\n    return TimerManagement;\r\n}());\r\nexport { TimerManagement };\r\n"]},"metadata":{},"sourceType":"module"}