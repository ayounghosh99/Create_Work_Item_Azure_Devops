{"ast":null,"code":"var LAYOUT_CALCULATION_MAX_TIMES = 5;\nexport var Location;\n\n(function (Location) {\n  Location[\"start\"] = \"start\";\n  Location[\"center\"] = \"center\";\n  Location[\"end\"] = \"end\";\n})(Location || (Location = {}));\n/**\r\n * Calculates the distance between two points\r\n * @param pointA First point\r\n * @param pointB Second point\r\n */\n\n\nexport function distance(pointA, pointB) {\n  return Math.sqrt(Math.pow(pointA.x - pointB.x, 2) + Math.pow(pointA.y - pointB.y, 2));\n}\n/**\r\n * The position method is used to set the location of an absolutely positioned element\r\n * using the standard positioning properties. The names of these properties conform to\r\n * the naming patterns used in the Material Popover https://material-ui.com. They\r\n * are not exact but follow the same pattern.\r\n *\r\n * For an example usage, look at the Callout component and how it uses this method to\r\n * position the element in the page.\r\n *\r\n * @param transformElement The element that is being positioned/transformed.\r\n * @param transformOrigin The origin within the transformed element to align with the\r\n *  anchor position.\r\n * @param anchorOffset Offset on the anchorElement that is applied to the computed location\r\n *  given the element/origin/point.\r\n * @param anchorElement The element used to anchor the position of the transformed element.\r\n *  The caller must supply either an anchorElement and anchorOrigin, or anchorPoint.\r\n * @param anchorOrigin When an anchorElement is supplied the anchorOrigin defines the location\r\n *  on the anchorElement used for positioning.\r\n * @param anchorPoint Instead of an anchorElement the caller can use an explicit point\r\n *  to be used as the basis for the anchorLocation. The anchorOffset will still be applied.\r\n * @param extraSpaceSize Sets the value of how much the container is larger than the window in all directions.\r\n */\n\nexport function position(transformElement, transformOrigin, anchorOffset, anchorElement, anchorOrigin, anchorPoint, extraSpaceSize) {\n  if (extraSpaceSize === void 0) {\n    extraSpaceSize = 5000;\n  } // Translate the anchor location information to a point on the anchor element\n  // if a specific point was not supplied.\n\n\n  if (!anchorPoint) {\n    if (anchorElement && anchorOrigin) {\n      anchorPoint = pointFromOrigin(anchorOrigin, anchorElement.getBoundingClientRect());\n    } else {\n      return;\n    }\n  }\n\n  var xPosition = anchorPoint.x;\n  var yPosition = anchorPoint.y;\n  var translateXFactor = 0;\n  var translateYFactor = 0; // Update the anchorPoint by the anchorOffset if one was supplied.\n\n  if (anchorOffset) {\n    xPosition += anchorOffset.horizontal;\n    yPosition += anchorOffset.vertical;\n  } // Special case Start/Start since we dont need the parent rect.\n\n\n  if (transformOrigin.horizontal !== Location.start || transformOrigin.vertical !== Location.start) {\n    var windowHeight = document.documentElement.clientHeight;\n    var windowWidth = document.documentElement.clientWidth; // Compute the effective horizontal position of the element.\n\n    switch (transformOrigin.horizontal) {\n      case Location.end:\n        xPosition = windowWidth - xPosition;\n        break;\n\n      case Location.center:\n        translateXFactor = -50;\n        break;\n\n      default:\n    } // Compute the effective vertical position of the element.\n\n\n    switch (transformOrigin.vertical) {\n      case Location.end:\n        yPosition = windowHeight - yPosition;\n        break;\n\n      case Location.center:\n        translateYFactor = -50;\n        break;\n\n      default:\n    }\n  } // Update the transform elements position (it needs to be absolutely positioned in the window).\n  // Void out other styles in case this is a re-call\n\n\n  if (transformOrigin.horizontal !== Location.end) {\n    transformElement.style.left = xPosition + extraSpaceSize + \"px\";\n    transformElement.style.right = \"\";\n  } else {\n    transformElement.style.left = \"\";\n    transformElement.style.right = xPosition + extraSpaceSize + \"px\";\n  }\n\n  if (transformOrigin.vertical !== Location.end) {\n    transformElement.style.top = yPosition + extraSpaceSize + \"px\";\n    transformElement.style.bottom = \"\";\n  } else {\n    transformElement.style.top = \"\";\n    transformElement.style.bottom = yPosition + extraSpaceSize + \"px\";\n  } // Apply centering as necessary\n\n\n  if (translateXFactor !== 0 || translateYFactor !== 0) {\n    transformElement.style.transform = \"translate(\" + translateXFactor + \"%, \" + translateYFactor + \"%)\";\n  } else {\n    transformElement.style.transform = \"\";\n  }\n}\n/**\r\n * updateLayout is used to move an element to the \"best\" location based on it\r\n * layout. This will look at all the positioning attributes and move the\r\n * transformElement to a new location based on its size. This is usually done\r\n * after an initial call to position. After the element is positioned the\r\n * caller determines if the transformElement is in the desired location, which\r\n * generally translates to, is it clipped in the window.\r\n *\r\n * This is delayed because when position is called the transformElement is\r\n * frequently not fully laid out and we need to wait other a force reflow will\r\n * happen and cause performance issues.\r\n *\r\n * @param transformElement The element that is being positioned/transformed.\r\n * @param transformOrigin The origin within the transformed element to align with the\r\n *  anchor position.\r\n * @param anchorOffset Offset on the anchorElement that is applied to the computed location\r\n *  given the element/origin/point.\r\n * @param anchorElement The element used to anchor the position of the transformed element.\r\n *  The caller must supply either an anchorElement and anchorOrigin, or anchorPoint.\r\n * @param anchorOrigin When an anchorElement is supplie the anchorOrigin defines the location\r\n *  on the anchorElement used for positioning.\r\n * @param anchorPoint Instead of an anchorElement the caller can use an explicit point\r\n *  to be used as the basis for the anchorLocation. The anchorOffset will still be applied.\r\n * @param recursionControl Use it to avoid infinite loop and call this function LAYOUT_CALCULATION_MAX_TIMES times at most.\r\n * @param extraSpaceSize Sets the value of how much the container is larger than the window in all directions.\r\n */\n\nexport function updateLayout(transformElement, transformOrigin, anchorOffset, anchorElement, anchorOrigin, anchorPoint, recursionControl, extraSpaceSize) {\n  if (recursionControl === void 0) {\n    recursionControl = 0;\n  }\n\n  if (extraSpaceSize === void 0) {\n    extraSpaceSize = 5000;\n  }\n\n  var windowHeight = document.documentElement.clientHeight;\n  var windowWidth = document.documentElement.clientWidth; // Get the current layout for the transformElement to determine the best layout.\n\n  var transformElementRect = transformElement.getBoundingClientRect(); // Determine which edges of the transform element are clipped by the window.\n\n  var clippedBottom = Math.floor(transformElementRect.bottom) > windowHeight;\n  var clippedRight = Math.floor(transformElementRect.right) > windowWidth;\n  var clippedLeft = Math.floor(transformElementRect.left) < 0;\n  var clippedTop = Math.floor(transformElementRect.top) < 0; // If any of the edges are clipped we will update the layout to a better layout if available.\n\n  if (clippedBottom || clippedRight || clippedLeft || clippedTop) {\n    // If we are positioned based on a point and and offset we will flip over\n    // the clipped edge.\n    if (anchorPoint) {\n      // Flip vertically top/bottom depending on the clipping edges.\n      if (clippedTop !== clippedBottom) {\n        if (clippedTop) {\n          // Before we flip lets make sure we have at least 10 more pixels the other direction.\n          if (transformElementRect.bottom < windowHeight / 2 - 10) {\n            if (transformOrigin.vertical === Location.end) {\n              transformOrigin.vertical = Location.start;\n            }\n          }\n        } else {\n          // Before we flip lets make sure we have at least 10 more pixels the other direction.\n          if (transformElementRect.top > windowHeight / 2 + 10) {\n            if (transformOrigin.vertical === Location.start) {\n              transformOrigin.vertical = Location.end;\n            }\n          }\n        }\n\n        if (anchorOffset) {\n          anchorOffset.vertical = -anchorOffset.vertical;\n        }\n      } // Flip hoizontally left/right depending on the clipping edges.\n\n\n      if (clippedLeft !== clippedRight) {\n        if (clippedLeft) {\n          // Before we flip lets make sure we have at least 10 more pixels the other direction.\n          if (transformElementRect.right < windowWidth / 2 - 10) {\n            if (transformOrigin.horizontal === Location.end) {\n              transformOrigin.horizontal = Location.start;\n            }\n          }\n        } else {\n          // Before we flip lets make sure we have at least 10 more pixels the other direction.\n          if (transformElementRect.left > windowWidth / 2 + 10) {\n            if (transformOrigin.horizontal === Location.start) {\n              transformOrigin.horizontal = Location.end;\n            }\n          }\n        }\n\n        if (anchorOffset) {\n          anchorOffset.horizontal = -anchorOffset.horizontal;\n        }\n      }\n    } // If the element is positioned based on an anchorElement/anchorOrigin\n    // we need to look determine if the element can slide along any axis.\n    else if (anchorOrigin && anchorElement) {\n        // Flip vertically top/bottom depending on the clipping edges.\n        if (clippedTop !== clippedBottom) {\n          if (clippedTop) {\n            // Before we flip lets make sure we have at least 10 more pixels the other direction.\n            if (transformElementRect.bottom < windowHeight / 2 - 10) {\n              if (transformOrigin.vertical === Location.end && anchorOrigin.vertical === Location.start) {\n                transformOrigin.vertical = Location.start;\n                anchorOrigin.vertical = Location.end;\n              } else if (transformOrigin.vertical === Location.center || transformOrigin.vertical === Location.end && anchorOrigin.vertical === Location.end) {\n                transformOrigin.vertical = Location.start;\n                anchorOrigin.vertical = Location.start;\n              }\n            }\n          } else {\n            // Before we flip lets make sure we have at least 10 more pixels the other direction.\n            if (transformElementRect.top > windowHeight / 2 + 10) {\n              if (transformOrigin.vertical === Location.start && anchorOrigin.vertical === Location.end) {\n                transformOrigin.vertical = Location.end;\n                anchorOrigin.vertical = Location.start;\n              } else if (transformOrigin.vertical === Location.center || transformOrigin.vertical === Location.start && anchorOrigin.vertical === Location.start) {\n                transformOrigin.vertical = Location.end;\n                anchorOrigin.vertical = Location.end;\n              }\n            }\n          }\n\n          if (anchorOffset) {\n            anchorOffset.vertical = -anchorOffset.vertical;\n          }\n        }\n\n        if (clippedLeft !== clippedRight) {\n          // Flip hoizontally left/right depending on the clipping edges.\n          if (clippedLeft) {\n            // Before we flip lets make sure we have at least 10 more pixels the other direction.\n            if (transformElementRect.right < windowWidth / 2 - 10) {\n              if (transformOrigin.horizontal === Location.end && anchorOrigin.horizontal === Location.start) {\n                transformOrigin.horizontal = Location.start;\n                anchorOrigin.horizontal = Location.end;\n              } else if (transformOrigin.horizontal === Location.center || transformOrigin.horizontal === Location.end && anchorOrigin.horizontal === Location.end) {\n                transformOrigin.horizontal = Location.start;\n                anchorOrigin.horizontal = Location.start;\n              }\n            }\n          } else {\n            // Before we flip lets make sure we have at least 10 more pixels the other direction.\n            if (transformElementRect.left > windowWidth / 2 + 10) {\n              if (transformOrigin.horizontal === Location.start && anchorOrigin.horizontal === Location.end) {\n                transformOrigin.horizontal = Location.end;\n                anchorOrigin.horizontal = Location.start;\n              } else if (transformOrigin.horizontal === Location.center || transformOrigin.horizontal === Location.start && anchorOrigin.horizontal === Location.start) {\n                transformOrigin.horizontal = Location.end;\n                anchorOrigin.horizontal = Location.end;\n              }\n            }\n          }\n\n          if (anchorOffset) {\n            anchorOffset.horizontal = -anchorOffset.horizontal;\n          }\n        }\n      } // Update the position based on the changes made to the location details.\n\n\n    position(transformElement, transformOrigin, anchorOffset, anchorElement, anchorOrigin, anchorPoint, extraSpaceSize); // If the repositioned element doesnt fit, we will put max-height/max-width to\n    // force the entire element into the viewport.\n\n    transformElementRect = transformElement.getBoundingClientRect(); // Determine which edges of the transform element are clipped by the window.\n\n    clippedBottom = Math.floor(transformElementRect.bottom) > windowHeight;\n    clippedRight = Math.floor(transformElementRect.right) > windowWidth;\n    clippedLeft = Math.floor(transformElementRect.left) < 0;\n    clippedTop = Math.floor(transformElementRect.top) < 0; // Since we are clipped compute the updated sizes and position a second time.\n\n    if (clippedTop || clippedBottom || clippedLeft || clippedRight) {\n      if (clippedTop || clippedBottom) {\n        var maxHeight = transformElementRect.height - (clippedTop ? -transformElementRect.top : 0) - (clippedBottom ? transformElementRect.bottom - windowHeight : 0) - 5;\n        transformElement.style.maxHeight = maxHeight + \"px\";\n      }\n\n      if (clippedLeft || clippedRight) {\n        var maxWidth = transformElementRect.width - (clippedLeft ? -transformElementRect.left : 0) - (clippedRight ? transformElementRect.right - windowWidth : 0) - 5;\n        transformElement.style.maxWidth = maxWidth + \"px\";\n      } // Note the change to the component with the overflow className.\n\n\n      transformElement.classList.add(\"overflow\");\n      position(transformElement, transformOrigin, anchorOffset, anchorElement, anchorOrigin, anchorPoint, extraSpaceSize);\n\n      if (recursionControl < LAYOUT_CALCULATION_MAX_TIMES) {\n        // Since we changed width/height of the control, let's check if it's cut-off.\n        transformElementRect = transformElement.getBoundingClientRect();\n        clippedBottom = Math.floor(transformElementRect.bottom) > windowHeight;\n        clippedRight = Math.floor(transformElementRect.right) > windowWidth;\n        clippedLeft = Math.floor(transformElementRect.left) < 0;\n        clippedTop = Math.floor(transformElementRect.top) < 0; // Go through all the logic one more time if tooltip doesn't fit in.\n\n        if (clippedBottom || clippedRight || clippedLeft || clippedTop) {\n          updateLayout(transformElement, transformOrigin, anchorOffset, anchorElement, anchorOrigin, anchorPoint, ++recursionControl);\n        }\n      }\n    }\n  }\n}\n\nfunction pointFromOrigin(location, rect) {\n  var x;\n  var y; // Compute the horizontal position based on the rectangle.\n\n  switch (location.horizontal) {\n    case Location.start:\n      x = rect.left;\n      break;\n\n    case Location.end:\n      x = rect.right;\n      break;\n\n    default:\n      x = rect.left + rect.width / 2;\n  } // Compute the vertical position based on the rectangle.\n\n\n  switch (location.vertical) {\n    case Location.start:\n      y = rect.top;\n      break;\n\n    case Location.end:\n      y = rect.bottom;\n      break;\n\n    default:\n      y = rect.top + rect.height / 2;\n  }\n\n  return {\n    x: x,\n    y: y\n  };\n}","map":{"version":3,"sources":["/Users/ayounghosh/Downloads/Create_Work_Item_Azure_Devops/Front_End/node_modules/azure-devops-ui/Utilities/Position.js"],"names":["LAYOUT_CALCULATION_MAX_TIMES","Location","distance","pointA","pointB","Math","sqrt","pow","x","y","position","transformElement","transformOrigin","anchorOffset","anchorElement","anchorOrigin","anchorPoint","extraSpaceSize","pointFromOrigin","getBoundingClientRect","xPosition","yPosition","translateXFactor","translateYFactor","horizontal","vertical","start","windowHeight","document","documentElement","clientHeight","windowWidth","clientWidth","end","center","style","left","right","top","bottom","transform","updateLayout","recursionControl","transformElementRect","clippedBottom","floor","clippedRight","clippedLeft","clippedTop","maxHeight","height","maxWidth","width","classList","add","location","rect"],"mappings":"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","sourcesContent":["var LAYOUT_CALCULATION_MAX_TIMES = 5;\r\nexport var Location;\r\n(function (Location) {\r\n    Location[\"start\"] = \"start\";\r\n    Location[\"center\"] = \"center\";\r\n    Location[\"end\"] = \"end\";\r\n})(Location || (Location = {}));\r\n/**\r\n * Calculates the distance between two points\r\n * @param pointA First point\r\n * @param pointB Second point\r\n */\r\nexport function distance(pointA, pointB) {\r\n    return Math.sqrt(Math.pow(pointA.x - pointB.x, 2) + Math.pow(pointA.y - pointB.y, 2));\r\n}\r\n/**\r\n * The position method is used to set the location of an absolutely positioned element\r\n * using the standard positioning properties. The names of these properties conform to\r\n * the naming patterns used in the Material Popover https://material-ui.com. They\r\n * are not exact but follow the same pattern.\r\n *\r\n * For an example usage, look at the Callout component and how it uses this method to\r\n * position the element in the page.\r\n *\r\n * @param transformElement The element that is being positioned/transformed.\r\n * @param transformOrigin The origin within the transformed element to align with the\r\n *  anchor position.\r\n * @param anchorOffset Offset on the anchorElement that is applied to the computed location\r\n *  given the element/origin/point.\r\n * @param anchorElement The element used to anchor the position of the transformed element.\r\n *  The caller must supply either an anchorElement and anchorOrigin, or anchorPoint.\r\n * @param anchorOrigin When an anchorElement is supplied the anchorOrigin defines the location\r\n *  on the anchorElement used for positioning.\r\n * @param anchorPoint Instead of an anchorElement the caller can use an explicit point\r\n *  to be used as the basis for the anchorLocation. The anchorOffset will still be applied.\r\n * @param extraSpaceSize Sets the value of how much the container is larger than the window in all directions.\r\n */\r\nexport function position(transformElement, transformOrigin, anchorOffset, anchorElement, anchorOrigin, anchorPoint, extraSpaceSize) {\r\n    if (extraSpaceSize === void 0) { extraSpaceSize = 5000; }\r\n    // Translate the anchor location information to a point on the anchor element\r\n    // if a specific point was not supplied.\r\n    if (!anchorPoint) {\r\n        if (anchorElement && anchorOrigin) {\r\n            anchorPoint = pointFromOrigin(anchorOrigin, anchorElement.getBoundingClientRect());\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n    }\r\n    var xPosition = anchorPoint.x;\r\n    var yPosition = anchorPoint.y;\r\n    var translateXFactor = 0;\r\n    var translateYFactor = 0;\r\n    // Update the anchorPoint by the anchorOffset if one was supplied.\r\n    if (anchorOffset) {\r\n        xPosition += anchorOffset.horizontal;\r\n        yPosition += anchorOffset.vertical;\r\n    }\r\n    // Special case Start/Start since we dont need the parent rect.\r\n    if (transformOrigin.horizontal !== Location.start || transformOrigin.vertical !== Location.start) {\r\n        var windowHeight = document.documentElement.clientHeight;\r\n        var windowWidth = document.documentElement.clientWidth;\r\n        // Compute the effective horizontal position of the element.\r\n        switch (transformOrigin.horizontal) {\r\n            case Location.end:\r\n                xPosition = windowWidth - xPosition;\r\n                break;\r\n            case Location.center:\r\n                translateXFactor = -50;\r\n                break;\r\n            default:\r\n        }\r\n        // Compute the effective vertical position of the element.\r\n        switch (transformOrigin.vertical) {\r\n            case Location.end:\r\n                yPosition = windowHeight - yPosition;\r\n                break;\r\n            case Location.center:\r\n                translateYFactor = -50;\r\n                break;\r\n            default:\r\n        }\r\n    }\r\n    // Update the transform elements position (it needs to be absolutely positioned in the window).\r\n    // Void out other styles in case this is a re-call\r\n    if (transformOrigin.horizontal !== Location.end) {\r\n        transformElement.style.left = xPosition + extraSpaceSize + \"px\";\r\n        transformElement.style.right = \"\";\r\n    }\r\n    else {\r\n        transformElement.style.left = \"\";\r\n        transformElement.style.right = xPosition + extraSpaceSize + \"px\";\r\n    }\r\n    if (transformOrigin.vertical !== Location.end) {\r\n        transformElement.style.top = yPosition + extraSpaceSize + \"px\";\r\n        transformElement.style.bottom = \"\";\r\n    }\r\n    else {\r\n        transformElement.style.top = \"\";\r\n        transformElement.style.bottom = yPosition + extraSpaceSize + \"px\";\r\n    }\r\n    // Apply centering as necessary\r\n    if (translateXFactor !== 0 || translateYFactor !== 0) {\r\n        transformElement.style.transform = \"translate(\" + translateXFactor + \"%, \" + translateYFactor + \"%)\";\r\n    }\r\n    else {\r\n        transformElement.style.transform = \"\";\r\n    }\r\n}\r\n/**\r\n * updateLayout is used to move an element to the \"best\" location based on it\r\n * layout. This will look at all the positioning attributes and move the\r\n * transformElement to a new location based on its size. This is usually done\r\n * after an initial call to position. After the element is positioned the\r\n * caller determines if the transformElement is in the desired location, which\r\n * generally translates to, is it clipped in the window.\r\n *\r\n * This is delayed because when position is called the transformElement is\r\n * frequently not fully laid out and we need to wait other a force reflow will\r\n * happen and cause performance issues.\r\n *\r\n * @param transformElement The element that is being positioned/transformed.\r\n * @param transformOrigin The origin within the transformed element to align with the\r\n *  anchor position.\r\n * @param anchorOffset Offset on the anchorElement that is applied to the computed location\r\n *  given the element/origin/point.\r\n * @param anchorElement The element used to anchor the position of the transformed element.\r\n *  The caller must supply either an anchorElement and anchorOrigin, or anchorPoint.\r\n * @param anchorOrigin When an anchorElement is supplie the anchorOrigin defines the location\r\n *  on the anchorElement used for positioning.\r\n * @param anchorPoint Instead of an anchorElement the caller can use an explicit point\r\n *  to be used as the basis for the anchorLocation. The anchorOffset will still be applied.\r\n * @param recursionControl Use it to avoid infinite loop and call this function LAYOUT_CALCULATION_MAX_TIMES times at most.\r\n * @param extraSpaceSize Sets the value of how much the container is larger than the window in all directions.\r\n */\r\nexport function updateLayout(transformElement, transformOrigin, anchorOffset, anchorElement, anchorOrigin, anchorPoint, recursionControl, extraSpaceSize) {\r\n    if (recursionControl === void 0) { recursionControl = 0; }\r\n    if (extraSpaceSize === void 0) { extraSpaceSize = 5000; }\r\n    var windowHeight = document.documentElement.clientHeight;\r\n    var windowWidth = document.documentElement.clientWidth;\r\n    // Get the current layout for the transformElement to determine the best layout.\r\n    var transformElementRect = transformElement.getBoundingClientRect();\r\n    // Determine which edges of the transform element are clipped by the window.\r\n    var clippedBottom = Math.floor(transformElementRect.bottom) > windowHeight;\r\n    var clippedRight = Math.floor(transformElementRect.right) > windowWidth;\r\n    var clippedLeft = Math.floor(transformElementRect.left) < 0;\r\n    var clippedTop = Math.floor(transformElementRect.top) < 0;\r\n    // If any of the edges are clipped we will update the layout to a better layout if available.\r\n    if (clippedBottom || clippedRight || clippedLeft || clippedTop) {\r\n        // If we are positioned based on a point and and offset we will flip over\r\n        // the clipped edge.\r\n        if (anchorPoint) {\r\n            // Flip vertically top/bottom depending on the clipping edges.\r\n            if (clippedTop !== clippedBottom) {\r\n                if (clippedTop) {\r\n                    // Before we flip lets make sure we have at least 10 more pixels the other direction.\r\n                    if (transformElementRect.bottom < windowHeight / 2 - 10) {\r\n                        if (transformOrigin.vertical === Location.end) {\r\n                            transformOrigin.vertical = Location.start;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // Before we flip lets make sure we have at least 10 more pixels the other direction.\r\n                    if (transformElementRect.top > windowHeight / 2 + 10) {\r\n                        if (transformOrigin.vertical === Location.start) {\r\n                            transformOrigin.vertical = Location.end;\r\n                        }\r\n                    }\r\n                }\r\n                if (anchorOffset) {\r\n                    anchorOffset.vertical = -anchorOffset.vertical;\r\n                }\r\n            }\r\n            // Flip hoizontally left/right depending on the clipping edges.\r\n            if (clippedLeft !== clippedRight) {\r\n                if (clippedLeft) {\r\n                    // Before we flip lets make sure we have at least 10 more pixels the other direction.\r\n                    if (transformElementRect.right < windowWidth / 2 - 10) {\r\n                        if (transformOrigin.horizontal === Location.end) {\r\n                            transformOrigin.horizontal = Location.start;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // Before we flip lets make sure we have at least 10 more pixels the other direction.\r\n                    if (transformElementRect.left > windowWidth / 2 + 10) {\r\n                        if (transformOrigin.horizontal === Location.start) {\r\n                            transformOrigin.horizontal = Location.end;\r\n                        }\r\n                    }\r\n                }\r\n                if (anchorOffset) {\r\n                    anchorOffset.horizontal = -anchorOffset.horizontal;\r\n                }\r\n            }\r\n        }\r\n        // If the element is positioned based on an anchorElement/anchorOrigin\r\n        // we need to look determine if the element can slide along any axis.\r\n        else if (anchorOrigin && anchorElement) {\r\n            // Flip vertically top/bottom depending on the clipping edges.\r\n            if (clippedTop !== clippedBottom) {\r\n                if (clippedTop) {\r\n                    // Before we flip lets make sure we have at least 10 more pixels the other direction.\r\n                    if (transformElementRect.bottom < windowHeight / 2 - 10) {\r\n                        if (transformOrigin.vertical === Location.end && anchorOrigin.vertical === Location.start) {\r\n                            transformOrigin.vertical = Location.start;\r\n                            anchorOrigin.vertical = Location.end;\r\n                        }\r\n                        else if (transformOrigin.vertical === Location.center ||\r\n                            (transformOrigin.vertical === Location.end && anchorOrigin.vertical === Location.end)) {\r\n                            transformOrigin.vertical = Location.start;\r\n                            anchorOrigin.vertical = Location.start;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // Before we flip lets make sure we have at least 10 more pixels the other direction.\r\n                    if (transformElementRect.top > windowHeight / 2 + 10) {\r\n                        if (transformOrigin.vertical === Location.start && anchorOrigin.vertical === Location.end) {\r\n                            transformOrigin.vertical = Location.end;\r\n                            anchorOrigin.vertical = Location.start;\r\n                        }\r\n                        else if (transformOrigin.vertical === Location.center ||\r\n                            (transformOrigin.vertical === Location.start && anchorOrigin.vertical === Location.start)) {\r\n                            transformOrigin.vertical = Location.end;\r\n                            anchorOrigin.vertical = Location.end;\r\n                        }\r\n                    }\r\n                }\r\n                if (anchorOffset) {\r\n                    anchorOffset.vertical = -anchorOffset.vertical;\r\n                }\r\n            }\r\n            if (clippedLeft !== clippedRight) {\r\n                // Flip hoizontally left/right depending on the clipping edges.\r\n                if (clippedLeft) {\r\n                    // Before we flip lets make sure we have at least 10 more pixels the other direction.\r\n                    if (transformElementRect.right < windowWidth / 2 - 10) {\r\n                        if (transformOrigin.horizontal === Location.end && anchorOrigin.horizontal === Location.start) {\r\n                            transformOrigin.horizontal = Location.start;\r\n                            anchorOrigin.horizontal = Location.end;\r\n                        }\r\n                        else if (transformOrigin.horizontal === Location.center ||\r\n                            (transformOrigin.horizontal === Location.end && anchorOrigin.horizontal === Location.end)) {\r\n                            transformOrigin.horizontal = Location.start;\r\n                            anchorOrigin.horizontal = Location.start;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // Before we flip lets make sure we have at least 10 more pixels the other direction.\r\n                    if (transformElementRect.left > windowWidth / 2 + 10) {\r\n                        if (transformOrigin.horizontal === Location.start && anchorOrigin.horizontal === Location.end) {\r\n                            transformOrigin.horizontal = Location.end;\r\n                            anchorOrigin.horizontal = Location.start;\r\n                        }\r\n                        else if (transformOrigin.horizontal === Location.center ||\r\n                            (transformOrigin.horizontal === Location.start && anchorOrigin.horizontal === Location.start)) {\r\n                            transformOrigin.horizontal = Location.end;\r\n                            anchorOrigin.horizontal = Location.end;\r\n                        }\r\n                    }\r\n                }\r\n                if (anchorOffset) {\r\n                    anchorOffset.horizontal = -anchorOffset.horizontal;\r\n                }\r\n            }\r\n        }\r\n        // Update the position based on the changes made to the location details.\r\n        position(transformElement, transformOrigin, anchorOffset, anchorElement, anchorOrigin, anchorPoint, extraSpaceSize);\r\n        // If the repositioned element doesnt fit, we will put max-height/max-width to\r\n        // force the entire element into the viewport.\r\n        transformElementRect = transformElement.getBoundingClientRect();\r\n        // Determine which edges of the transform element are clipped by the window.\r\n        clippedBottom = Math.floor(transformElementRect.bottom) > windowHeight;\r\n        clippedRight = Math.floor(transformElementRect.right) > windowWidth;\r\n        clippedLeft = Math.floor(transformElementRect.left) < 0;\r\n        clippedTop = Math.floor(transformElementRect.top) < 0;\r\n        // Since we are clipped compute the updated sizes and position a second time.\r\n        if (clippedTop || clippedBottom || clippedLeft || clippedRight) {\r\n            if (clippedTop || clippedBottom) {\r\n                var maxHeight = transformElementRect.height -\r\n                    (clippedTop ? -transformElementRect.top : 0) -\r\n                    (clippedBottom ? transformElementRect.bottom - windowHeight : 0) -\r\n                    5;\r\n                transformElement.style.maxHeight = maxHeight + \"px\";\r\n            }\r\n            if (clippedLeft || clippedRight) {\r\n                var maxWidth = transformElementRect.width -\r\n                    (clippedLeft ? -transformElementRect.left : 0) -\r\n                    (clippedRight ? transformElementRect.right - windowWidth : 0) -\r\n                    5;\r\n                transformElement.style.maxWidth = maxWidth + \"px\";\r\n            }\r\n            // Note the change to the component with the overflow className.\r\n            transformElement.classList.add(\"overflow\");\r\n            position(transformElement, transformOrigin, anchorOffset, anchorElement, anchorOrigin, anchorPoint, extraSpaceSize);\r\n            if (recursionControl < LAYOUT_CALCULATION_MAX_TIMES) {\r\n                // Since we changed width/height of the control, let's check if it's cut-off.\r\n                transformElementRect = transformElement.getBoundingClientRect();\r\n                clippedBottom = Math.floor(transformElementRect.bottom) > windowHeight;\r\n                clippedRight = Math.floor(transformElementRect.right) > windowWidth;\r\n                clippedLeft = Math.floor(transformElementRect.left) < 0;\r\n                clippedTop = Math.floor(transformElementRect.top) < 0;\r\n                // Go through all the logic one more time if tooltip doesn't fit in.\r\n                if (clippedBottom || clippedRight || clippedLeft || clippedTop) {\r\n                    updateLayout(transformElement, transformOrigin, anchorOffset, anchorElement, anchorOrigin, anchorPoint, ++recursionControl);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction pointFromOrigin(location, rect) {\r\n    var x;\r\n    var y;\r\n    // Compute the horizontal position based on the rectangle.\r\n    switch (location.horizontal) {\r\n        case Location.start:\r\n            x = rect.left;\r\n            break;\r\n        case Location.end:\r\n            x = rect.right;\r\n            break;\r\n        default:\r\n            x = rect.left + rect.width / 2;\r\n    }\r\n    // Compute the vertical position based on the rectangle.\r\n    switch (location.vertical) {\r\n        case Location.start:\r\n            y = rect.top;\r\n            break;\r\n        case Location.end:\r\n            y = rect.bottom;\r\n            break;\r\n        default:\r\n            y = rect.top + rect.height / 2;\r\n    }\r\n    return { x: x, y: y };\r\n}\r\n"]},"metadata":{},"sourceType":"module"}