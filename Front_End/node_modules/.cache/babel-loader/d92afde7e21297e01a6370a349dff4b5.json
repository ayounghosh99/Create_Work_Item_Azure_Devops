{"ast":null,"code":"import * as React from \"react\";\n/**\r\n * Set of KeyCodes that are used in the platform.\r\n */\n\nexport var KeyCode;\n\n(function (KeyCode) {\n  KeyCode[KeyCode[\"backspace\"] = 8] = \"backspace\";\n  KeyCode[KeyCode[\"tab\"] = 9] = \"tab\";\n  KeyCode[KeyCode[\"enter\"] = 13] = \"enter\";\n  KeyCode[KeyCode[\"shift\"] = 16] = \"shift\";\n  KeyCode[KeyCode[\"ctrl\"] = 17] = \"ctrl\";\n  KeyCode[KeyCode[\"alt\"] = 18] = \"alt\";\n  KeyCode[KeyCode[\"pause\"] = 19] = \"pause\";\n  KeyCode[KeyCode[\"capsLock\"] = 20] = \"capsLock\";\n  KeyCode[KeyCode[\"escape\"] = 27] = \"escape\";\n  KeyCode[KeyCode[\"space\"] = 32] = \"space\";\n  KeyCode[KeyCode[\"pageUp\"] = 33] = \"pageUp\";\n  KeyCode[KeyCode[\"pageDown\"] = 34] = \"pageDown\";\n  KeyCode[KeyCode[\"end\"] = 35] = \"end\";\n  KeyCode[KeyCode[\"home\"] = 36] = \"home\";\n  KeyCode[KeyCode[\"leftArrow\"] = 37] = \"leftArrow\";\n  KeyCode[KeyCode[\"upArrow\"] = 38] = \"upArrow\";\n  KeyCode[KeyCode[\"rightArrow\"] = 39] = \"rightArrow\";\n  KeyCode[KeyCode[\"downArrow\"] = 40] = \"downArrow\";\n  KeyCode[KeyCode[\"delete\"] = 46] = \"delete\";\n  KeyCode[KeyCode[\"b\"] = 66] = \"b\";\n  KeyCode[KeyCode[\"i\"] = 73] = \"i\";\n  KeyCode[KeyCode[\"k\"] = 75] = \"k\";\n  KeyCode[KeyCode[\"q\"] = 81] = \"q\";\n  KeyCode[KeyCode[\"t\"] = 84] = \"t\";\n  KeyCode[KeyCode[\"windowsKey\"] = 91] = \"windowsKey\";\n  KeyCode[KeyCode[\"macCommand\"] = 91] = \"macCommand\";\n  KeyCode[KeyCode[\"F10\"] = 121] = \"F10\";\n  KeyCode[KeyCode[\"numLock\"] = 144] = \"numLock\";\n  KeyCode[KeyCode[\"scrollLock\"] = 145] = \"scrollLock\";\n  KeyCode[KeyCode[\"comma\"] = 188] = \"comma\";\n})(KeyCode || (KeyCode = {}));\n/**\r\n * Determines whether or not a keystroke is an arrow key or not.\r\n */\n\n\nexport function isArrowKey(event) {\n  return event.which === KeyCode.downArrow || event.which === KeyCode.upArrow || event.which === KeyCode.leftArrow || event.which === KeyCode.rightArrow;\n}\n/**\r\n * Type guard function to determine if children are defined as a function\r\n * @param children (usually from this.props.children)\r\n */\n\nexport function isFunctionalChildren(children) {\n  return typeof children === \"function\";\n}\n/**\r\n * childCount is used to determine the number of defined renderable children within\r\n * a standard set of React.Children. This is different than React.Children.length\r\n * which includes children that are null or undefined.\r\n */\n\nexport function childCount(children) {\n  var childCount = 0;\n  React.Children.forEach(children, function (child) {\n    if (child) {\n      childCount++;\n    }\n  });\n  return childCount;\n}\n/**\r\n * getSafeId is designed to create a string from the input id that is safe for use\r\n * as the id attribute of a component. The ids appear in the global javscript namespace.\r\n * This means if you create an element and assign the \"id\" property to a value\r\n * the element is accessible by doing window.<id>. This causes problems when the\r\n * id of the element collides with other global objects. Using a SafeId adds a prefix\r\n * intended to avoid conflicts.\r\n *\r\n * This should be called anytime a DOM elements property is being set that refers to\r\n * the components id. This should not be called when passing the id as a prop to a\r\n * component. It is the components responsibility to make the Id safe when attaching\r\n * it to an element.\r\n *\r\n * This includes but is not limited to properties like:\r\n *  aria-controls, aria-describedby, aria-labelledby, id, htmlFor, ...\r\n *\r\n * @param id The root id that is being made \"Safe\".\r\n */\n\nexport function getSafeId(id) {\n  if (false) {\n    if (id && id.startsWith(\"__bolt-\")) {\n      console.error(\"getSafeId was called twice on id \" + id + \", it should only be called once\");\n    }\n  } // querySelector won't select id's with .'s in them replace them with '-'.\n\n\n  return id ? \"__bolt-\" + id.replace(/[^0-9A-Za-z_]/g, \"-\") : undefined;\n}\n/**\r\n * getSafeIdSelector will return the string that can use used to denote the selector\r\n * for elements that use this id.\r\n *\r\n * @param id The root id that is being made \"Safe\".\r\n */\n\nexport function getSafeIdSelector(id) {\n  return \"#\" + getSafeId(id);\n}\n/**\r\n * function that does nothing and accepts any set of arguments.\r\n */\n\nexport function noop() {}\n/**\r\n * Basic function for building a css classlist string from and array of classes, where\r\n * one of more of the arguments may be null or undefined.\r\n *\r\n * @param classes Array of strings the represents the css class list.\r\n *\r\n * @example css(\"base\", \"active\", x === 42 && \"optional\") will return \"base active optional\" if x === 42 or \"base active\" otherwise\r\n */\n\nexport function css() {\n  var classes = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    classes[_i] = arguments[_i];\n  }\n\n  return classes.filter(function (c) {\n    return c;\n  }).join(\" \").trim();\n}\n/**\r\n * Returns the set of parent elements with index 0 the root and the last\r\n * element is either the direct parent or itself based on includeSelf.\r\n *\r\n * @param element The element to get the parent element hierarchy from.\r\n * @param includeSelf Should the element supplied be included in the parent list.\r\n * @param rootElement Optional root element to stop processing\r\n * @param includeRoot Should the root element supplied be included in the parent list.\r\n */\n\nexport function getParents(element, includeSelf, rootElement, includeRoot) {\n  var parentElements = [];\n\n  if (includeSelf) {\n    parentElements.push(element);\n  }\n\n  while (element.parentElement && element.parentElement !== rootElement) {\n    parentElements.splice(0, 0, element.parentElement);\n    element = element.parentElement;\n  }\n\n  if (element.parentElement && includeRoot) {\n    parentElements.splice(0, 0, element.parentElement);\n  }\n\n  return parentElements;\n}\n/**\r\n * Determines if the target element of an event (or its ancestry) has a particular node name.\r\n *\r\n * @param event The initial element is pulled off of this event.\r\n * @param nodeNames A list of DOM node names (\"A\", \"INPUT\", etc.) to check for the presence\r\n * @param rootAncestor If provided, build a list of ancestors from the event's element, to this element to check. Otherwise,\r\n * only check the element from the event.\r\n */\n\nexport function eventTargetContainsNode(event, nodeNames, rootAncestor) {\n  var targetElement = event.target;\n  var ancestors = rootAncestor ? getParents(targetElement, true, rootAncestor, true) : [targetElement];\n  return ancestors.some(function (element) {\n    return nodeNames.indexOf(element.nodeName) !== -1;\n  });\n}\n/**\r\n * ElementRelationship is used to define how two elements in the same\r\n * document are related in position to each other.\r\n */\n\nexport var ElementRelationship;\n\n(function (ElementRelationship) {\n  ElementRelationship[ElementRelationship[\"Unrelated\"] = 0] = \"Unrelated\";\n  ElementRelationship[ElementRelationship[\"Before\"] = 1] = \"Before\";\n  ElementRelationship[ElementRelationship[\"After\"] = 2] = \"After\";\n  ElementRelationship[ElementRelationship[\"Child\"] = 3] = \"Child\";\n  ElementRelationship[ElementRelationship[\"Parent\"] = 4] = \"Parent\";\n})(ElementRelationship || (ElementRelationship = {}));\n/**\r\n * getRelationship returns the relationship of the two specified elements.\r\n *\r\n * @param element1\r\n * @param element2\r\n */\n\n\nexport function getRelationship(element1, element2) {\n  // If the second element is a child of the first element, then element1 occurs before element2.\n  if (element1.contains(element2)) {\n    return ElementRelationship.Parent;\n  } // If the first element is a child of the second element, then element1 occurs after element2.\n\n\n  if (element2.contains(element1)) {\n    return ElementRelationship.Child;\n  } // Retrieve the parents of both the elements.\n\n\n  var parents1 = getParents(element1, true);\n  var parents2 = getParents(element2, true);\n\n  for (var elementIndex = 0;; elementIndex++) {\n    if (parents1[elementIndex] !== parents2[elementIndex]) {\n      var siblings = parents1[elementIndex - 1].children;\n\n      for (var siblingIndex = 0; siblingIndex < siblings.length; siblingIndex++) {\n        if (siblings[siblingIndex] === parents1[elementIndex]) {\n          return ElementRelationship.Before;\n        }\n\n        if (siblings[siblingIndex] === parents2[elementIndex]) {\n          return ElementRelationship.After;\n        }\n      }\n    }\n  }\n}\n/**\r\n * preventDefault is used as a standard delegate to prevent the default behavior\r\n * for a given event.\r\n *\r\n * @param event Synthetic event that should have its default action prevented.\r\n */\n\nexport function preventDefault(event) {\n  event.preventDefault();\n}\n/**\r\n * shimRef is used to acquire a React Ref from a child component. If the child\r\n * has an existing ref, it will return the existing ref, if not it will\r\n * create a new one.\r\n */\n\nexport function shimRef(child) {\n  // @HACK: This uses an internal property on the created element which is the\n  //  forwarded ref property of the element. If React ever changes the implementation\n  //  removing this property this code will need to be updated.\n  // @NOTE: The ref MUST be a React.createRef if the a ref property is specified,\n  //  otherwise we will not be able to share the ref.\n  var ref = child.ref; // If no ref was created by the element owner we will add one.\n\n  if (!ref) {\n    ref = React.createRef();\n  } else {\n    // @DEBUG: Ensure the ref is a React.createRef by validated the current property\n    if (!ref.hasOwnProperty(\"current\")) {\n      throw Error(\"Children of a focus zone MUST use React.createRef to obtain child references\");\n    } // @DEBUG\n\n  }\n\n  return ref;\n}\nvar focusVisible = false;\n/**\r\n * Determine whether or not focus is currently visible to the user. This generally\r\n * means the user is using the keyboard to manage focus instead of the mouse.\r\n */\n\nexport function getFocusVisible() {\n  return focusVisible;\n}\n/**\r\n * Make sure the focus treatment is enabled and disabled based on\r\n * the state of mouse and keyboard usage.\r\n */\n\nexport function setFocusVisible(visible) {\n  if ((focusVisible = visible) === true) {\n    document.body && document.body.classList.add(\"bolt-focus-visible\");\n  } else {\n    document.body && document.body.classList.remove(\"bolt-focus-visible\");\n  }\n}\n/* Setup the set of non-focus keys, when these are pressed it doesnt start showing focus treatment */\n\nvar nonFocusKeys = new Array(255);\nnonFocusKeys[KeyCode.alt] = true;\nnonFocusKeys[KeyCode.capsLock] = true;\nnonFocusKeys[KeyCode.ctrl] = true;\nnonFocusKeys[KeyCode.numLock] = true;\nnonFocusKeys[KeyCode.pause] = true;\nnonFocusKeys[KeyCode.scrollLock] = true;\nnonFocusKeys[KeyCode.shift] = true;\nnonFocusKeys[KeyCode.windowsKey] = true;\ndocument.addEventListener(\"keydown\", function (event) {\n  if (!nonFocusKeys[event.which]) {\n    setFocusVisible(true);\n  }\n}, true);\nvar mouseCapture; // MouseCaptureFunction is the global mouse handler we use to trap events and forward\n// them to the current capture if one exists.\n\nvar mouseCaptureFunction = function (event) {\n  // Track the position of the mouse as it moves.\n  Mouse.position.x = event.clientX;\n  Mouse.position.y = event.clientY; // Notify the mouse capture of the mouse movement and mouseup if one is signed up.\n\n  if (mouseCapture && mouseCapture.callback && mouseCapture.button === event.button) {\n    mouseCapture.callback(event);\n\n    if (event.type === \"mouseup\") {\n      Mouse.releaseCapture(mouseCapture.callback);\n    }\n  }\n};\n\nexport var Mouse = {\n  position: {\n    x: 0,\n    y: 0\n  },\n  releaseCapture: function releaseCapture(callback) {\n    if (mouseCapture && mouseCapture.callback === callback) {\n      mouseCapture = undefined;\n    }\n  },\n  setCapture: function setCapture(callback, button) {\n    if (button === void 0) {\n      button = 0;\n    } // Before starting a new capture, we will release the current capture.\n\n\n    if (mouseCapture) {\n      Mouse.releaseCapture(mouseCapture.callback);\n    } // Update the mouseCapture to the new capture.\n\n\n    mouseCapture = {\n      button: button,\n      callback: callback\n    };\n  }\n};\ndocument.addEventListener(\"mousemove\", mouseCaptureFunction);\ndocument.addEventListener(\"mouseup\", mouseCaptureFunction);\ndocument.addEventListener(\"mousedown\", function (event) {\n  // Screen readers on scan mode trigger some key strokes as Mouse events.\n  // We can easily identify those events because they have no coordinates.\n  if (event.button === 0 && event.clientX === 0 && event.clientY === 0 && event.screenX === 0 && event.screenY === 0 && event.pageX === 0 && event.pageY === 0) {\n    return;\n  }\n\n  setFocusVisible(false);\n}, true);\nvar touchCapture; // touchCaptureFunction is the global touch handler we use to trap events and forward\n// them to the current capture if one exists.\n\nvar touchCaptureFunction = function (event) {\n  var touch = event.changedTouches && event.changedTouches.length ? event.changedTouches[0] : event.touches[0]; // Track the position of the touch as it moves.\n\n  Touch.position.x = touch.clientX;\n  Touch.position.y = touch.clientY; // Notify the touch capture of the touch movement and touchend if one is signed up.\n\n  if (touchCapture && touchCapture.callback) {\n    touchCapture.callback(event);\n\n    if (event.type === \"touchend\") {\n      Touch.releaseCapture(touchCapture.callback);\n    }\n  }\n};\n/**\r\n * Currently only basic touch support - assumes a single touch\r\n * throughout the touch operation.\r\n */\n\n\nexport var Touch = {\n  position: {\n    x: 0,\n    y: 0\n  },\n  releaseCapture: function releaseCapture(callback) {\n    if (touchCapture && touchCapture.callback === callback) {\n      touchCapture = undefined;\n    }\n  },\n  setCapture: function setCapture(callback) {\n    // Before starting a new capture, we will release the current capture.\n    if (touchCapture) {\n      Touch.releaseCapture(touchCapture.callback);\n    } // Update the touchCapture to the new capture.\n\n\n    touchCapture = {\n      callback: callback\n    };\n  }\n};\ndocument.addEventListener(\"touchmove\", touchCaptureFunction);\ndocument.addEventListener(\"touchend\", touchCaptureFunction);\ndocument.addEventListener(\"touchstart\", function () {\n  return setFocusVisible(false);\n}, true);\n/**\r\n * Returns the coordinates of a native event. For mouse / touch events, uses the\r\n * Mouse/Touch helpers. For a keyboard event, will return undefined.\r\n * @param event\r\n */\n\nexport function getPointByEventType(event) {\n  if (event.changedTouches || event.touches) {\n    // If the event has a changedTouches or touches property, it is a touch event.\n    return {\n      x: Touch.position.x,\n      y: Touch.position.y\n    };\n  } else if (event.clientX !== undefined) {\n    // If the event has a clientX, it is not a keyboard event, so treat it as a mouse event.\n    return {\n      x: Mouse.position.x,\n      y: Mouse.position.y\n    };\n  }\n\n  return undefined;\n}\n/**\r\n * Checks two arrays to see they contain equal elements in the same order.\r\n *\r\n * @param array1 First array to check.\r\n * @param array2 Second array to check.\r\n * @param comparer Optional comparer to check whether array items are equal. If not specified, items are compared using strict equals.\r\n * @returns {boolean}\r\n */\n\nexport function arrayEquals(array1, array2, comparer) {\n  if (comparer === void 0) {\n    comparer = function (item1, item2) {\n      return item1 === item2;\n    };\n  }\n\n  if (!array1 && !array2) {\n    return true;\n  }\n\n  if (!array1 || !array2) {\n    return false;\n  }\n\n  if (array1.length !== array2.length) {\n    return false;\n  }\n\n  for (var i = 0; i < array1.length; i++) {\n    if (!comparer(array1[i], array2[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}","map":{"version":3,"sources":["/Users/ayounghosh/Downloads/Create_Work_Item_Azure_Devops/Front_End/node_modules/azure-devops-ui/Util.js"],"names":["React","KeyCode","isArrowKey","event","which","downArrow","upArrow","leftArrow","rightArrow","isFunctionalChildren","children","childCount","Children","forEach","child","getSafeId","id","startsWith","console","error","replace","undefined","getSafeIdSelector","noop","css","classes","_i","arguments","length","filter","c","join","trim","getParents","element","includeSelf","rootElement","includeRoot","parentElements","push","parentElement","splice","eventTargetContainsNode","nodeNames","rootAncestor","targetElement","target","ancestors","some","indexOf","nodeName","ElementRelationship","getRelationship","element1","element2","contains","Parent","Child","parents1","parents2","elementIndex","siblings","siblingIndex","Before","After","preventDefault","shimRef","ref","createRef","hasOwnProperty","Error","focusVisible","getFocusVisible","setFocusVisible","visible","document","body","classList","add","remove","nonFocusKeys","Array","alt","capsLock","ctrl","numLock","pause","scrollLock","shift","windowsKey","addEventListener","mouseCapture","mouseCaptureFunction","Mouse","position","x","clientX","y","clientY","callback","button","type","releaseCapture","setCapture","screenX","screenY","pageX","pageY","touchCapture","touchCaptureFunction","touch","changedTouches","touches","Touch","getPointByEventType","arrayEquals","array1","array2","comparer","item1","item2","i"],"mappings":"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","sourcesContent":["import * as React from \"react\";\r\n/**\r\n * Set of KeyCodes that are used in the platform.\r\n */\r\nexport var KeyCode;\r\n(function (KeyCode) {\r\n    KeyCode[KeyCode[\"backspace\"] = 8] = \"backspace\";\r\n    KeyCode[KeyCode[\"tab\"] = 9] = \"tab\";\r\n    KeyCode[KeyCode[\"enter\"] = 13] = \"enter\";\r\n    KeyCode[KeyCode[\"shift\"] = 16] = \"shift\";\r\n    KeyCode[KeyCode[\"ctrl\"] = 17] = \"ctrl\";\r\n    KeyCode[KeyCode[\"alt\"] = 18] = \"alt\";\r\n    KeyCode[KeyCode[\"pause\"] = 19] = \"pause\";\r\n    KeyCode[KeyCode[\"capsLock\"] = 20] = \"capsLock\";\r\n    KeyCode[KeyCode[\"escape\"] = 27] = \"escape\";\r\n    KeyCode[KeyCode[\"space\"] = 32] = \"space\";\r\n    KeyCode[KeyCode[\"pageUp\"] = 33] = \"pageUp\";\r\n    KeyCode[KeyCode[\"pageDown\"] = 34] = \"pageDown\";\r\n    KeyCode[KeyCode[\"end\"] = 35] = \"end\";\r\n    KeyCode[KeyCode[\"home\"] = 36] = \"home\";\r\n    KeyCode[KeyCode[\"leftArrow\"] = 37] = \"leftArrow\";\r\n    KeyCode[KeyCode[\"upArrow\"] = 38] = \"upArrow\";\r\n    KeyCode[KeyCode[\"rightArrow\"] = 39] = \"rightArrow\";\r\n    KeyCode[KeyCode[\"downArrow\"] = 40] = \"downArrow\";\r\n    KeyCode[KeyCode[\"delete\"] = 46] = \"delete\";\r\n    KeyCode[KeyCode[\"b\"] = 66] = \"b\";\r\n    KeyCode[KeyCode[\"i\"] = 73] = \"i\";\r\n    KeyCode[KeyCode[\"k\"] = 75] = \"k\";\r\n    KeyCode[KeyCode[\"q\"] = 81] = \"q\";\r\n    KeyCode[KeyCode[\"t\"] = 84] = \"t\";\r\n    KeyCode[KeyCode[\"windowsKey\"] = 91] = \"windowsKey\";\r\n    KeyCode[KeyCode[\"macCommand\"] = 91] = \"macCommand\";\r\n    KeyCode[KeyCode[\"F10\"] = 121] = \"F10\";\r\n    KeyCode[KeyCode[\"numLock\"] = 144] = \"numLock\";\r\n    KeyCode[KeyCode[\"scrollLock\"] = 145] = \"scrollLock\";\r\n    KeyCode[KeyCode[\"comma\"] = 188] = \"comma\";\r\n})(KeyCode || (KeyCode = {}));\r\n/**\r\n * Determines whether or not a keystroke is an arrow key or not.\r\n */\r\nexport function isArrowKey(event) {\r\n    return (event.which === KeyCode.downArrow ||\r\n        event.which === KeyCode.upArrow ||\r\n        event.which === KeyCode.leftArrow ||\r\n        event.which === KeyCode.rightArrow);\r\n}\r\n/**\r\n * Type guard function to determine if children are defined as a function\r\n * @param children (usually from this.props.children)\r\n */\r\nexport function isFunctionalChildren(children) {\r\n    return typeof children === \"function\";\r\n}\r\n/**\r\n * childCount is used to determine the number of defined renderable children within\r\n * a standard set of React.Children. This is different than React.Children.length\r\n * which includes children that are null or undefined.\r\n */\r\nexport function childCount(children) {\r\n    var childCount = 0;\r\n    React.Children.forEach(children, function (child) {\r\n        if (child) {\r\n            childCount++;\r\n        }\r\n    });\r\n    return childCount;\r\n}\r\n/**\r\n * getSafeId is designed to create a string from the input id that is safe for use\r\n * as the id attribute of a component. The ids appear in the global javscript namespace.\r\n * This means if you create an element and assign the \"id\" property to a value\r\n * the element is accessible by doing window.<id>. This causes problems when the\r\n * id of the element collides with other global objects. Using a SafeId adds a prefix\r\n * intended to avoid conflicts.\r\n *\r\n * This should be called anytime a DOM elements property is being set that refers to\r\n * the components id. This should not be called when passing the id as a prop to a\r\n * component. It is the components responsibility to make the Id safe when attaching\r\n * it to an element.\r\n *\r\n * This includes but is not limited to properties like:\r\n *  aria-controls, aria-describedby, aria-labelledby, id, htmlFor, ...\r\n *\r\n * @param id The root id that is being made \"Safe\".\r\n */\r\nexport function getSafeId(id) {\r\n    if (false) {\r\n        if (id && id.startsWith(\"__bolt-\")) {\r\n            console.error(\"getSafeId was called twice on id \" + id + \", it should only be called once\");\r\n        }\r\n    }\r\n    // querySelector won't select id's with .'s in them replace them with '-'.\r\n    return id ? \"__bolt-\" + id.replace(/[^0-9A-Za-z_]/g, \"-\") : undefined;\r\n}\r\n/**\r\n * getSafeIdSelector will return the string that can use used to denote the selector\r\n * for elements that use this id.\r\n *\r\n * @param id The root id that is being made \"Safe\".\r\n */\r\nexport function getSafeIdSelector(id) {\r\n    return \"#\" + getSafeId(id);\r\n}\r\n/**\r\n * function that does nothing and accepts any set of arguments.\r\n */\r\nexport function noop() { }\r\n/**\r\n * Basic function for building a css classlist string from and array of classes, where\r\n * one of more of the arguments may be null or undefined.\r\n *\r\n * @param classes Array of strings the represents the css class list.\r\n *\r\n * @example css(\"base\", \"active\", x === 42 && \"optional\") will return \"base active optional\" if x === 42 or \"base active\" otherwise\r\n */\r\nexport function css() {\r\n    var classes = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        classes[_i] = arguments[_i];\r\n    }\r\n    return classes\r\n        .filter(function (c) { return c; })\r\n        .join(\" \")\r\n        .trim();\r\n}\r\n/**\r\n * Returns the set of parent elements with index 0 the root and the last\r\n * element is either the direct parent or itself based on includeSelf.\r\n *\r\n * @param element The element to get the parent element hierarchy from.\r\n * @param includeSelf Should the element supplied be included in the parent list.\r\n * @param rootElement Optional root element to stop processing\r\n * @param includeRoot Should the root element supplied be included in the parent list.\r\n */\r\nexport function getParents(element, includeSelf, rootElement, includeRoot) {\r\n    var parentElements = [];\r\n    if (includeSelf) {\r\n        parentElements.push(element);\r\n    }\r\n    while (element.parentElement && element.parentElement !== rootElement) {\r\n        parentElements.splice(0, 0, element.parentElement);\r\n        element = element.parentElement;\r\n    }\r\n    if (element.parentElement && includeRoot) {\r\n        parentElements.splice(0, 0, element.parentElement);\r\n    }\r\n    return parentElements;\r\n}\r\n/**\r\n * Determines if the target element of an event (or its ancestry) has a particular node name.\r\n *\r\n * @param event The initial element is pulled off of this event.\r\n * @param nodeNames A list of DOM node names (\"A\", \"INPUT\", etc.) to check for the presence\r\n * @param rootAncestor If provided, build a list of ancestors from the event's element, to this element to check. Otherwise,\r\n * only check the element from the event.\r\n */\r\nexport function eventTargetContainsNode(event, nodeNames, rootAncestor) {\r\n    var targetElement = event.target;\r\n    var ancestors = rootAncestor ? getParents(targetElement, true, rootAncestor, true) : [targetElement];\r\n    return ancestors.some(function (element) { return nodeNames.indexOf(element.nodeName) !== -1; });\r\n}\r\n/**\r\n * ElementRelationship is used to define how two elements in the same\r\n * document are related in position to each other.\r\n */\r\nexport var ElementRelationship;\r\n(function (ElementRelationship) {\r\n    ElementRelationship[ElementRelationship[\"Unrelated\"] = 0] = \"Unrelated\";\r\n    ElementRelationship[ElementRelationship[\"Before\"] = 1] = \"Before\";\r\n    ElementRelationship[ElementRelationship[\"After\"] = 2] = \"After\";\r\n    ElementRelationship[ElementRelationship[\"Child\"] = 3] = \"Child\";\r\n    ElementRelationship[ElementRelationship[\"Parent\"] = 4] = \"Parent\";\r\n})(ElementRelationship || (ElementRelationship = {}));\r\n/**\r\n * getRelationship returns the relationship of the two specified elements.\r\n *\r\n * @param element1\r\n * @param element2\r\n */\r\nexport function getRelationship(element1, element2) {\r\n    // If the second element is a child of the first element, then element1 occurs before element2.\r\n    if (element1.contains(element2)) {\r\n        return ElementRelationship.Parent;\r\n    }\r\n    // If the first element is a child of the second element, then element1 occurs after element2.\r\n    if (element2.contains(element1)) {\r\n        return ElementRelationship.Child;\r\n    }\r\n    // Retrieve the parents of both the elements.\r\n    var parents1 = getParents(element1, true);\r\n    var parents2 = getParents(element2, true);\r\n    for (var elementIndex = 0;; elementIndex++) {\r\n        if (parents1[elementIndex] !== parents2[elementIndex]) {\r\n            var siblings = parents1[elementIndex - 1].children;\r\n            for (var siblingIndex = 0; siblingIndex < siblings.length; siblingIndex++) {\r\n                if (siblings[siblingIndex] === parents1[elementIndex]) {\r\n                    return ElementRelationship.Before;\r\n                }\r\n                if (siblings[siblingIndex] === parents2[elementIndex]) {\r\n                    return ElementRelationship.After;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * preventDefault is used as a standard delegate to prevent the default behavior\r\n * for a given event.\r\n *\r\n * @param event Synthetic event that should have its default action prevented.\r\n */\r\nexport function preventDefault(event) {\r\n    event.preventDefault();\r\n}\r\n/**\r\n * shimRef is used to acquire a React Ref from a child component. If the child\r\n * has an existing ref, it will return the existing ref, if not it will\r\n * create a new one.\r\n */\r\nexport function shimRef(child) {\r\n    // @HACK: This uses an internal property on the created element which is the\r\n    //  forwarded ref property of the element. If React ever changes the implementation\r\n    //  removing this property this code will need to be updated.\r\n    // @NOTE: The ref MUST be a React.createRef if the a ref property is specified,\r\n    //  otherwise we will not be able to share the ref.\r\n    var ref = child.ref;\r\n    // If no ref was created by the element owner we will add one.\r\n    if (!ref) {\r\n        ref = React.createRef();\r\n    }\r\n    else {\r\n        // @DEBUG: Ensure the ref is a React.createRef by validated the current property\r\n        if (!ref.hasOwnProperty(\"current\")) {\r\n            throw Error(\"Children of a focus zone MUST use React.createRef to obtain child references\");\r\n        }\r\n        // @DEBUG\r\n    }\r\n    return ref;\r\n}\r\nvar focusVisible = false;\r\n/**\r\n * Determine whether or not focus is currently visible to the user. This generally\r\n * means the user is using the keyboard to manage focus instead of the mouse.\r\n */\r\nexport function getFocusVisible() {\r\n    return focusVisible;\r\n}\r\n/**\r\n * Make sure the focus treatment is enabled and disabled based on\r\n * the state of mouse and keyboard usage.\r\n */\r\nexport function setFocusVisible(visible) {\r\n    if ((focusVisible = visible) === true) {\r\n        document.body && document.body.classList.add(\"bolt-focus-visible\");\r\n    }\r\n    else {\r\n        document.body && document.body.classList.remove(\"bolt-focus-visible\");\r\n    }\r\n}\r\n/* Setup the set of non-focus keys, when these are pressed it doesnt start showing focus treatment */\r\nvar nonFocusKeys = new Array(255);\r\nnonFocusKeys[KeyCode.alt] = true;\r\nnonFocusKeys[KeyCode.capsLock] = true;\r\nnonFocusKeys[KeyCode.ctrl] = true;\r\nnonFocusKeys[KeyCode.numLock] = true;\r\nnonFocusKeys[KeyCode.pause] = true;\r\nnonFocusKeys[KeyCode.scrollLock] = true;\r\nnonFocusKeys[KeyCode.shift] = true;\r\nnonFocusKeys[KeyCode.windowsKey] = true;\r\ndocument.addEventListener(\"keydown\", function (event) {\r\n    if (!nonFocusKeys[event.which]) {\r\n        setFocusVisible(true);\r\n    }\r\n}, true);\r\nvar mouseCapture;\r\n// MouseCaptureFunction is the global mouse handler we use to trap events and forward\r\n// them to the current capture if one exists.\r\nvar mouseCaptureFunction = function (event) {\r\n    // Track the position of the mouse as it moves.\r\n    Mouse.position.x = event.clientX;\r\n    Mouse.position.y = event.clientY;\r\n    // Notify the mouse capture of the mouse movement and mouseup if one is signed up.\r\n    if (mouseCapture && mouseCapture.callback && mouseCapture.button === event.button) {\r\n        mouseCapture.callback(event);\r\n        if (event.type === \"mouseup\") {\r\n            Mouse.releaseCapture(mouseCapture.callback);\r\n        }\r\n    }\r\n};\r\nexport var Mouse = {\r\n    position: {\r\n        x: 0,\r\n        y: 0\r\n    },\r\n    releaseCapture: function releaseCapture(callback) {\r\n        if (mouseCapture && mouseCapture.callback === callback) {\r\n            mouseCapture = undefined;\r\n        }\r\n    },\r\n    setCapture: function setCapture(callback, button) {\r\n        if (button === void 0) { button = 0; }\r\n        // Before starting a new capture, we will release the current capture.\r\n        if (mouseCapture) {\r\n            Mouse.releaseCapture(mouseCapture.callback);\r\n        }\r\n        // Update the mouseCapture to the new capture.\r\n        mouseCapture = { button: button, callback: callback };\r\n    }\r\n};\r\ndocument.addEventListener(\"mousemove\", mouseCaptureFunction);\r\ndocument.addEventListener(\"mouseup\", mouseCaptureFunction);\r\ndocument.addEventListener(\"mousedown\", function (event) {\r\n    // Screen readers on scan mode trigger some key strokes as Mouse events.\r\n    // We can easily identify those events because they have no coordinates.\r\n    if (event.button === 0 &&\r\n        event.clientX === 0 &&\r\n        event.clientY === 0 &&\r\n        event.screenX === 0 &&\r\n        event.screenY === 0 &&\r\n        event.pageX === 0 &&\r\n        event.pageY === 0) {\r\n        return;\r\n    }\r\n    setFocusVisible(false);\r\n}, true);\r\nvar touchCapture;\r\n// touchCaptureFunction is the global touch handler we use to trap events and forward\r\n// them to the current capture if one exists.\r\nvar touchCaptureFunction = function (event) {\r\n    var touch = event.changedTouches && event.changedTouches.length ? event.changedTouches[0] : event.touches[0];\r\n    // Track the position of the touch as it moves.\r\n    Touch.position.x = touch.clientX;\r\n    Touch.position.y = touch.clientY;\r\n    // Notify the touch capture of the touch movement and touchend if one is signed up.\r\n    if (touchCapture && touchCapture.callback) {\r\n        touchCapture.callback(event);\r\n        if (event.type === \"touchend\") {\r\n            Touch.releaseCapture(touchCapture.callback);\r\n        }\r\n    }\r\n};\r\n/**\r\n * Currently only basic touch support - assumes a single touch\r\n * throughout the touch operation.\r\n */\r\nexport var Touch = {\r\n    position: {\r\n        x: 0,\r\n        y: 0\r\n    },\r\n    releaseCapture: function releaseCapture(callback) {\r\n        if (touchCapture && touchCapture.callback === callback) {\r\n            touchCapture = undefined;\r\n        }\r\n    },\r\n    setCapture: function setCapture(callback) {\r\n        // Before starting a new capture, we will release the current capture.\r\n        if (touchCapture) {\r\n            Touch.releaseCapture(touchCapture.callback);\r\n        }\r\n        // Update the touchCapture to the new capture.\r\n        touchCapture = { callback: callback };\r\n    }\r\n};\r\ndocument.addEventListener(\"touchmove\", touchCaptureFunction);\r\ndocument.addEventListener(\"touchend\", touchCaptureFunction);\r\ndocument.addEventListener(\"touchstart\", function () { return setFocusVisible(false); }, true);\r\n/**\r\n * Returns the coordinates of a native event. For mouse / touch events, uses the\r\n * Mouse/Touch helpers. For a keyboard event, will return undefined.\r\n * @param event\r\n */\r\nexport function getPointByEventType(event) {\r\n    if (event.changedTouches || event.touches) {\r\n        // If the event has a changedTouches or touches property, it is a touch event.\r\n        return { x: Touch.position.x, y: Touch.position.y };\r\n    }\r\n    else if (event.clientX !== undefined) {\r\n        // If the event has a clientX, it is not a keyboard event, so treat it as a mouse event.\r\n        return { x: Mouse.position.x, y: Mouse.position.y };\r\n    }\r\n    return undefined;\r\n}\r\n/**\r\n * Checks two arrays to see they contain equal elements in the same order.\r\n *\r\n * @param array1 First array to check.\r\n * @param array2 Second array to check.\r\n * @param comparer Optional comparer to check whether array items are equal. If not specified, items are compared using strict equals.\r\n * @returns {boolean}\r\n */\r\nexport function arrayEquals(array1, array2, comparer) {\r\n    if (comparer === void 0) { comparer = function (item1, item2) { return item1 === item2; }; }\r\n    if (!array1 && !array2) {\r\n        return true;\r\n    }\r\n    if (!array1 || !array2) {\r\n        return false;\r\n    }\r\n    if (array1.length !== array2.length) {\r\n        return false;\r\n    }\r\n    for (var i = 0; i < array1.length; i++) {\r\n        if (!comparer(array1[i], array2[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}