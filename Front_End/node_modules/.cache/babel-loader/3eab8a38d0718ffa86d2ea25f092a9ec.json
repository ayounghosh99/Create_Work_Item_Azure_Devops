{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport \"../../CommonImports\";\nimport \"../../Core/core.css\";\nimport * as React from \"react\";\nimport { ObservableLike } from '../../Core/Observable';\n/**\r\n * Handles subscription to properties that are IObservableValues, so that components don't have to handle on their own.\r\n *\r\n * Usage:\r\n *\r\n * <Observer myObservableValue={observableValue} className='foo'>\r\n *     <MyComponent myObservableValue='' />\r\n * </Observer>\r\n *\r\n * Your component will get re-rendered with the new value of myObservableValue whenever that value changes.\r\n * Additionally, any additional props set on the Observer will also get passed down.\r\n */\n\nvar Observer =\n/** @class */\nfunction (_super) {\n  __extends(Observer, _super);\n\n  function Observer(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.subscriptions = {}; // Initialize the state with the initial value of the observable.\n\n    var state = {\n      values: {},\n      oldProps: {}\n    };\n\n    for (var propName in props) {\n      state.values[propName] = getPropValue(props[propName]);\n    }\n\n    _this.state = state;\n    return _this;\n  }\n\n  Observer.getDerivedStateFromProps = function (props, state) {\n    var newState = updateSubscriptionsAndState(state.oldProps, props, state);\n\n    if (newState != null) {\n      return __assign(__assign({}, newState), {\n        oldProps: props\n      });\n    }\n\n    return {\n      oldProps: props\n    };\n  };\n\n  Observer.prototype.render = function () {\n    var newProps = {}; // Copy over any properties from the observable component to the children.\n\n    for (var key in this.state.values) {\n      if (key !== \"children\") {\n        newProps[key] = this.state.values[key];\n      }\n    }\n\n    if (typeof this.props.children === \"function\") {\n      var child = this.props.children;\n      return child(newProps);\n    } else {\n      var child = React.Children.only(this.props.children);\n      return React.cloneElement(child, __assign(__assign({}, child.props), newProps), child.props.children);\n    }\n  };\n\n  Observer.prototype.componentDidMount = function () {\n    this.updateSubscriptionsAndStateAfterRender();\n  };\n\n  Observer.prototype.componentDidUpdate = function () {\n    this.updateSubscriptionsAndStateAfterRender();\n\n    if (this.props.onUpdate) {\n      this.props.onUpdate();\n    }\n  };\n\n  Observer.prototype.componentWillUnmount = function () {\n    // Unsubscribe from any of the observable properties.\n    for (var propName in this.subscribedProps) {\n      this.unsubscribe(propName, this.subscribedProps);\n    }\n  };\n\n  Observer.prototype.subscribe = function (propName, props) {\n    if (propName !== \"children\") {\n      var observableExpression = void 0;\n      var observableValue = props[propName];\n      var action = void 0; // If this is an observableExpression, we need to subscribe to the value\n      // and execute the filter on changes.\n\n      if (observableValue && observableValue.observableValue !== undefined) {\n        observableExpression = observableValue;\n        observableValue = observableExpression.observableValue;\n        action = observableExpression.action;\n      }\n\n      if (ObservableLike.isObservable(observableValue)) {\n        var delegate = this.onValueChanged.bind(this, propName, observableValue, observableExpression);\n        ObservableLike.subscribe(observableValue, delegate, action);\n        this.subscriptions[propName] = {\n          delegate: delegate,\n          action: action\n        };\n      }\n    }\n  };\n\n  Observer.prototype.unsubscribe = function (propName, props) {\n    if (propName !== \"children\") {\n      var observableValue = getObservableValue(props[propName]);\n\n      if (ObservableLike.isObservable(observableValue)) {\n        var subscription = this.subscriptions[propName];\n        ObservableLike.unsubscribe(observableValue, subscription.delegate, subscription.action);\n        delete this.subscriptions[propName];\n      }\n    }\n  };\n\n  Observer.prototype.updateSubscriptionsAndStateAfterRender = function () {\n    var newState = updateSubscriptionsAndState(this.subscribedProps, this.props, this.state, this);\n\n    if (newState != null) {\n      this.setState(newState);\n    }\n\n    this.subscribedProps = __assign({}, this.props);\n  };\n\n  Observer.prototype.onValueChanged = function (propName, observableValue, observableExpression, value, action) {\n    var setState = true;\n\n    if (!(propName in this.subscriptions)) {\n      return;\n    } // If this is an ObservableExpression we will call the filter before setting state.\n\n\n    if (observableExpression && observableExpression.filter) {\n      setState = observableExpression.filter(value, action);\n    }\n\n    if (setState) {\n      this.setState(function (prevState, props) {\n        var _a;\n\n        return {\n          values: __assign(__assign({}, prevState.values), (_a = {}, _a[propName] = observableValue.value || value, _a))\n        };\n      });\n    }\n  };\n\n  return Observer;\n}(React.Component);\n\nexport { Observer };\n\nfunction getObservableValue(propValue) {\n  if (propValue && propValue.observableValue !== undefined) {\n    return propValue.observableValue;\n  }\n\n  return propValue;\n}\n\nfunction getPropValue(propValue) {\n  return ObservableLike.getValue(getObservableValue(propValue));\n}\n\nfunction updateSubscriptionsAndState(oldProps, newProps, state, component) {\n  // We need to unsubscribe from any observable values on old props and\n  // subscribe to any observable values on new props.\n  // In addition, if any of the values of the observables on the new props\n  // differ from the value on the state, then we need to update the state.\n  // This is possible if the value of the observable changed while the value\n  // was being rendered, but before we had set up the subscription.\n  // If we want to unsubscribe/resubscribe, then a component should be passed,\n  // since this method is always called statically.\n  var newState = __assign({}, state);\n\n  var stateChanged = false;\n\n  if (oldProps) {\n    for (var propName in oldProps) {\n      var oldValue = getObservableValue(oldProps[propName]);\n      var newValue = getObservableValue(newProps[propName]);\n\n      if (oldValue !== newValue) {\n        component && component.unsubscribe(propName, oldProps);\n\n        if (newValue === undefined) {\n          delete newState.values[propName];\n          stateChanged = true;\n        }\n      }\n    }\n  }\n\n  for (var propName in newProps) {\n    var oldValue = oldProps && getObservableValue(oldProps[propName]);\n    var newValue = getObservableValue(newProps[propName]);\n\n    if (oldValue !== newValue) {\n      component && component.subscribe(propName, newProps); // Look for changes in the observables between creation and now.\n\n      if (state.values[propName] !== getPropValue(newValue)) {\n        newState.values[propName] = getPropValue(newValue);\n        stateChanged = true;\n      }\n    }\n  } // If any state updates occurred update the state now.\n\n\n  if (stateChanged) {\n    return newState;\n  }\n\n  return null;\n}","map":{"version":3,"sources":["/Users/ayounghosh/Downloads/Create_Work_Item_Azure_Devops/Front_End/node_modules/azure-devops-ui/Components/Observer/Observer.js"],"names":["__assign","__extends","React","ObservableLike","Observer","_super","props","_this","call","subscriptions","state","values","oldProps","propName","getPropValue","getDerivedStateFromProps","newState","updateSubscriptionsAndState","prototype","render","newProps","key","children","child","Children","only","cloneElement","componentDidMount","updateSubscriptionsAndStateAfterRender","componentDidUpdate","onUpdate","componentWillUnmount","subscribedProps","unsubscribe","subscribe","observableExpression","observableValue","action","undefined","isObservable","delegate","onValueChanged","bind","getObservableValue","subscription","setState","value","filter","prevState","_a","Component","propValue","getValue","component","stateChanged","oldValue","newValue"],"mappings":"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","sourcesContent":["import { __assign, __extends } from \"tslib\";\r\nimport \"../../CommonImports\";\r\nimport \"../../Core/core.css\";\r\nimport * as React from \"react\";\r\nimport { ObservableLike } from '../../Core/Observable';\r\n/**\r\n * Handles subscription to properties that are IObservableValues, so that components don't have to handle on their own.\r\n *\r\n * Usage:\r\n *\r\n * <Observer myObservableValue={observableValue} className='foo'>\r\n *     <MyComponent myObservableValue='' />\r\n * </Observer>\r\n *\r\n * Your component will get re-rendered with the new value of myObservableValue whenever that value changes.\r\n * Additionally, any additional props set on the Observer will also get passed down.\r\n */\r\nvar Observer = /** @class */ (function (_super) {\r\n    __extends(Observer, _super);\r\n    function Observer(props) {\r\n        var _this = _super.call(this, props) || this;\r\n        _this.subscriptions = {};\r\n        // Initialize the state with the initial value of the observable.\r\n        var state = { values: {}, oldProps: {} };\r\n        for (var propName in props) {\r\n            state.values[propName] = getPropValue(props[propName]);\r\n        }\r\n        _this.state = state;\r\n        return _this;\r\n    }\r\n    Observer.getDerivedStateFromProps = function (props, state) {\r\n        var newState = updateSubscriptionsAndState(state.oldProps, props, state);\r\n        if (newState != null) {\r\n            return __assign(__assign({}, newState), { oldProps: props });\r\n        }\r\n        return { oldProps: props };\r\n    };\r\n    Observer.prototype.render = function () {\r\n        var newProps = {};\r\n        // Copy over any properties from the observable component to the children.\r\n        for (var key in this.state.values) {\r\n            if (key !== \"children\") {\r\n                newProps[key] = this.state.values[key];\r\n            }\r\n        }\r\n        if (typeof this.props.children === \"function\") {\r\n            var child = this.props.children;\r\n            return child(newProps);\r\n        }\r\n        else {\r\n            var child = React.Children.only(this.props.children);\r\n            return React.cloneElement(child, __assign(__assign({}, child.props), newProps), child.props.children);\r\n        }\r\n    };\r\n    Observer.prototype.componentDidMount = function () {\r\n        this.updateSubscriptionsAndStateAfterRender();\r\n    };\r\n    Observer.prototype.componentDidUpdate = function () {\r\n        this.updateSubscriptionsAndStateAfterRender();\r\n        if (this.props.onUpdate) {\r\n            this.props.onUpdate();\r\n        }\r\n    };\r\n    Observer.prototype.componentWillUnmount = function () {\r\n        // Unsubscribe from any of the observable properties.\r\n        for (var propName in this.subscribedProps) {\r\n            this.unsubscribe(propName, this.subscribedProps);\r\n        }\r\n    };\r\n    Observer.prototype.subscribe = function (propName, props) {\r\n        if (propName !== \"children\") {\r\n            var observableExpression = void 0;\r\n            var observableValue = props[propName];\r\n            var action = void 0;\r\n            // If this is an observableExpression, we need to subscribe to the value\r\n            // and execute the filter on changes.\r\n            if (observableValue && observableValue.observableValue !== undefined) {\r\n                observableExpression = observableValue;\r\n                observableValue = observableExpression.observableValue;\r\n                action = observableExpression.action;\r\n            }\r\n            if (ObservableLike.isObservable(observableValue)) {\r\n                var delegate = this.onValueChanged.bind(this, propName, observableValue, observableExpression);\r\n                ObservableLike.subscribe(observableValue, delegate, action);\r\n                this.subscriptions[propName] = { delegate: delegate, action: action };\r\n            }\r\n        }\r\n    };\r\n    Observer.prototype.unsubscribe = function (propName, props) {\r\n        if (propName !== \"children\") {\r\n            var observableValue = getObservableValue(props[propName]);\r\n            if (ObservableLike.isObservable(observableValue)) {\r\n                var subscription = this.subscriptions[propName];\r\n                ObservableLike.unsubscribe(observableValue, subscription.delegate, subscription.action);\r\n                delete this.subscriptions[propName];\r\n            }\r\n        }\r\n    };\r\n    Observer.prototype.updateSubscriptionsAndStateAfterRender = function () {\r\n        var newState = updateSubscriptionsAndState(this.subscribedProps, this.props, this.state, this);\r\n        if (newState != null) {\r\n            this.setState(newState);\r\n        }\r\n        this.subscribedProps = __assign({}, this.props);\r\n    };\r\n    Observer.prototype.onValueChanged = function (propName, observableValue, observableExpression, value, action) {\r\n        var setState = true;\r\n        if (!(propName in this.subscriptions)) {\r\n            return;\r\n        }\r\n        // If this is an ObservableExpression we will call the filter before setting state.\r\n        if (observableExpression && observableExpression.filter) {\r\n            setState = observableExpression.filter(value, action);\r\n        }\r\n        if (setState) {\r\n            this.setState(function (prevState, props) {\r\n                var _a;\r\n                return {\r\n                    values: __assign(__assign({}, prevState.values), (_a = {}, _a[propName] = observableValue.value || value, _a))\r\n                };\r\n            });\r\n        }\r\n    };\r\n    return Observer;\r\n}(React.Component));\r\nexport { Observer };\r\nfunction getObservableValue(propValue) {\r\n    if (propValue && propValue.observableValue !== undefined) {\r\n        return propValue.observableValue;\r\n    }\r\n    return propValue;\r\n}\r\nfunction getPropValue(propValue) {\r\n    return ObservableLike.getValue(getObservableValue(propValue));\r\n}\r\nfunction updateSubscriptionsAndState(oldProps, newProps, state, component) {\r\n    // We need to unsubscribe from any observable values on old props and\r\n    // subscribe to any observable values on new props.\r\n    // In addition, if any of the values of the observables on the new props\r\n    // differ from the value on the state, then we need to update the state.\r\n    // This is possible if the value of the observable changed while the value\r\n    // was being rendered, but before we had set up the subscription.\r\n    // If we want to unsubscribe/resubscribe, then a component should be passed,\r\n    // since this method is always called statically.\r\n    var newState = __assign({}, state);\r\n    var stateChanged = false;\r\n    if (oldProps) {\r\n        for (var propName in oldProps) {\r\n            var oldValue = getObservableValue(oldProps[propName]);\r\n            var newValue = getObservableValue(newProps[propName]);\r\n            if (oldValue !== newValue) {\r\n                component && component.unsubscribe(propName, oldProps);\r\n                if (newValue === undefined) {\r\n                    delete newState.values[propName];\r\n                    stateChanged = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (var propName in newProps) {\r\n        var oldValue = oldProps && getObservableValue(oldProps[propName]);\r\n        var newValue = getObservableValue(newProps[propName]);\r\n        if (oldValue !== newValue) {\r\n            component && component.subscribe(propName, newProps);\r\n            // Look for changes in the observables between creation and now.\r\n            if (state.values[propName] !== getPropValue(newValue)) {\r\n                newState.values[propName] = getPropValue(newValue);\r\n                stateChanged = true;\r\n            }\r\n        }\r\n    }\r\n    // If any state updates occurred update the state now.\r\n    if (stateChanged) {\r\n        return newState;\r\n    }\r\n    return null;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}