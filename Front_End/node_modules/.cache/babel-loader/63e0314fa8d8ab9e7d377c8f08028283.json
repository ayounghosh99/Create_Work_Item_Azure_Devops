{"ast":null,"code":"import { noop } from '../Util';\nimport { getWindow } from \"./Dom\";\n/**\r\n * getTabIndex takes in a standard set of focus related properties to determine\r\n * the correct tabIndex for the element.\r\n */\n\nexport function getTabIndex(props, focusGroupContext) {\n  // Return an explicit tabIndex if one was requested.\n  if (props.tabIndex !== undefined) {\n    return props.tabIndex;\n  } // Make element tabbable if:\n  //  The element is not disabled,\n  //  The element does not have the excludeTabStop property\n  //  Optionally, the component is within a focusGroup and is the focused element\n\n\n  if (!props.disabled && !props.excludeTabStop && (!focusGroupContext || focusGroupContext.onFocus === noop || focusGroupContext.focusedElementId === props.id)) {\n    return 0;\n  } // Allow the element to have focus as long as the excludeFocusZone was not supplied.\n\n\n  if (!props.excludeFocusZone) {\n    return -1;\n  } // The element is not tabbable and wont have a tabIndex, therefore it can't get focus.\n\n\n  return undefined;\n}\nvar targetToFocusOnNextRepaint = undefined;\n/**\r\n * Sets focus on the next frame OR after setTimeout(0)\r\n * If you pass an IFocusable instead of an HTMLElement it'll use setTimeout instead of window.requestAnimationFrame\r\n */\n\nexport function focusAsync(element) {\n  // If we've called this method this frame, re-set the element to focus but don't hook up another handler\n  if (targetToFocusOnNextRepaint) {\n    targetToFocusOnNextRepaint = element;\n    return;\n  } // If this is the first time we've called this this frame, set an event handler\n  // or schedule it async if we can't get the window element\n\n\n  targetToFocusOnNextRepaint = element;\n  var window = getWindow(element);\n\n  if (window) {\n    window.requestAnimationFrame(function () {\n      if (targetToFocusOnNextRepaint) {\n        targetToFocusOnNextRepaint.focus();\n      }\n\n      targetToFocusOnNextRepaint = undefined;\n    });\n  } else {\n    setTimeout(function () {\n      if (targetToFocusOnNextRepaint) {\n        targetToFocusOnNextRepaint.focus();\n      }\n    });\n  }\n}","map":{"version":3,"sources":["/Users/ayounghosh/Downloads/Create_Work_Item_Azure_Devops/Front_End/node_modules/azure-devops-ui/Utilities/Focus.js"],"names":["noop","getWindow","getTabIndex","props","focusGroupContext","tabIndex","undefined","disabled","excludeTabStop","onFocus","focusedElementId","id","excludeFocusZone","targetToFocusOnNextRepaint","focusAsync","element","window","requestAnimationFrame","focus","setTimeout"],"mappings":"AAAA,SAASA,IAAT,QAAqB,SAArB;AACA,SAASC,SAAT,QAA0B,OAA1B;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,WAAT,CAAqBC,KAArB,EAA4BC,iBAA5B,EAA+C;AAClD;AACA,MAAID,KAAK,CAACE,QAAN,KAAmBC,SAAvB,EAAkC;AAC9B,WAAOH,KAAK,CAACE,QAAb;AACH,GAJiD,CAKlD;AACA;AACA;AACA;;;AACA,MAAI,CAACF,KAAK,CAACI,QAAP,IACA,CAACJ,KAAK,CAACK,cADP,KAEC,CAACJ,iBAAD,IAAsBA,iBAAiB,CAACK,OAAlB,KAA8BT,IAApD,IAA4DI,iBAAiB,CAACM,gBAAlB,KAAuCP,KAAK,CAACQ,EAF1G,CAAJ,EAEmH;AAC/G,WAAO,CAAP;AACH,GAbiD,CAclD;;;AACA,MAAI,CAACR,KAAK,CAACS,gBAAX,EAA6B;AACzB,WAAO,CAAC,CAAR;AACH,GAjBiD,CAkBlD;;;AACA,SAAON,SAAP;AACH;AACD,IAAIO,0BAA0B,GAAGP,SAAjC;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASQ,UAAT,CAAoBC,OAApB,EAA6B;AAChC;AACA,MAAIF,0BAAJ,EAAgC;AAC5BA,IAAAA,0BAA0B,GAAGE,OAA7B;AACA;AACH,GAL+B,CAMhC;AACA;;;AACAF,EAAAA,0BAA0B,GAAGE,OAA7B;AACA,MAAIC,MAAM,GAAGf,SAAS,CAACc,OAAD,CAAtB;;AACA,MAAIC,MAAJ,EAAY;AACRA,IAAAA,MAAM,CAACC,qBAAP,CAA6B,YAAY;AACrC,UAAIJ,0BAAJ,EAAgC;AAC5BA,QAAAA,0BAA0B,CAACK,KAA3B;AACH;;AACDL,MAAAA,0BAA0B,GAAGP,SAA7B;AACH,KALD;AAMH,GAPD,MAQK;AACDa,IAAAA,UAAU,CAAC,YAAY;AACnB,UAAIN,0BAAJ,EAAgC;AAC5BA,QAAAA,0BAA0B,CAACK,KAA3B;AACH;AACJ,KAJS,CAAV;AAKH;AACJ","sourcesContent":["import { noop } from '../Util';\r\nimport { getWindow } from \"./Dom\";\r\n/**\r\n * getTabIndex takes in a standard set of focus related properties to determine\r\n * the correct tabIndex for the element.\r\n */\r\nexport function getTabIndex(props, focusGroupContext) {\r\n    // Return an explicit tabIndex if one was requested.\r\n    if (props.tabIndex !== undefined) {\r\n        return props.tabIndex;\r\n    }\r\n    // Make element tabbable if:\r\n    //  The element is not disabled,\r\n    //  The element does not have the excludeTabStop property\r\n    //  Optionally, the component is within a focusGroup and is the focused element\r\n    if (!props.disabled &&\r\n        !props.excludeTabStop &&\r\n        (!focusGroupContext || focusGroupContext.onFocus === noop || focusGroupContext.focusedElementId === props.id)) {\r\n        return 0;\r\n    }\r\n    // Allow the element to have focus as long as the excludeFocusZone was not supplied.\r\n    if (!props.excludeFocusZone) {\r\n        return -1;\r\n    }\r\n    // The element is not tabbable and wont have a tabIndex, therefore it can't get focus.\r\n    return undefined;\r\n}\r\nvar targetToFocusOnNextRepaint = undefined;\r\n/**\r\n * Sets focus on the next frame OR after setTimeout(0)\r\n * If you pass an IFocusable instead of an HTMLElement it'll use setTimeout instead of window.requestAnimationFrame\r\n */\r\nexport function focusAsync(element) {\r\n    // If we've called this method this frame, re-set the element to focus but don't hook up another handler\r\n    if (targetToFocusOnNextRepaint) {\r\n        targetToFocusOnNextRepaint = element;\r\n        return;\r\n    }\r\n    // If this is the first time we've called this this frame, set an event handler\r\n    // or schedule it async if we can't get the window element\r\n    targetToFocusOnNextRepaint = element;\r\n    var window = getWindow(element);\r\n    if (window) {\r\n        window.requestAnimationFrame(function () {\r\n            if (targetToFocusOnNextRepaint) {\r\n                targetToFocusOnNextRepaint.focus();\r\n            }\r\n            targetToFocusOnNextRepaint = undefined;\r\n        });\r\n    }\r\n    else {\r\n        setTimeout(function () {\r\n            if (targetToFocusOnNextRepaint) {\r\n                targetToFocusOnNextRepaint.focus();\r\n            }\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}